# Адаптивный код
# Введение в скрам
Scrum - это гибкая методология управления проектами, ценность которой в итеративности
**Гибкая метеодология разработки требует гибкого кода, иначе вносимые изменения будет всем сложнее и медленнее**

Водопад не подразумевает движения в обратном направлении, т.е если завершили разработку и споткнулись на тестировании - путей обратно нет и получается комок грязи из исполнителей. Водопад не предполагает изменений или изменения избегаются

Скрам подразумевает, что изменения неизбежны и процесс построен так, чтобы учитывать адаптивность к изменениям

**Цель:** Писать код адаптивный к изменениям

В водопаде акцент на документацию, в скраме на ПО

## Роли
* владелец продцкта (связь с заказчиком, приоритеты, оценка следования требованиям)
* скрам-мастер (организация работы по скраму, защита от изменения спринта сверху)
* разработчики (специалисты, реализующие цели спринта)

## Артефакты
* Доска Scrum (реальная доска)
    * карточки для разных задач с разным цветом
        * зеленые - функциональные средства
        * белые - истории
        * желтые - задачи
        * красные - баги
        * фиолетовые - тех.долг
    * иерархия композиции - связи между карточками
    * продукт - что должно быть сделано
    * релиз - версия
    * функциональное средство. могут быть обязательные, предпочтительные, желательные
    * пользовательская история (формируется так (как, что, что сделать, когда)) анализируется, разбивается на задачи
    * задача - часть истории на конкретном разработчике
    * техдолг
    * баг
* беклог - упорядочен по приоритету
* тестирование
Горизонтальные дорожки для группирования по функциональному средству(истории с свамого верха, может быть дорожка для самых важных задач)

## Технический долг
Квадрат технической задолжности
|опреметчивая|благоразумная|
|------------|-------------|
|нет время на проектирвоание|выполним поставку, потом займется последствиями|

|неумышленная|благоразумная|
|------------|-------------|
|мы не знаем, что это такое, если бы мы знали, что это такое. ООП| мы знаем как должны были сделать

## Опредление законченности
Признаки:
* прошли модульные тесты
* прошло интеграционное тестирование
* корректное поведение по тест-куйсам
* прошло 

## Скорость
Скорость команды можно вычсилить после нескольких спринтов. Измерить в сторипоинтах. В дальнейшем скорость можно анализировать для оценки качества планирования

## Беклог
Беклог продукта: приоритет - это ценность задачи (функционального средства)
Беклог спинта - стори, которын долюны реализовать в спринте. Оценивается командой

## Спринт
Лучший запуск - середина недели
Планирование:
* определяется дата, приоритеты, функциональные средства
* покер (оценка стори в масштабе - числа фибоначи)
* митинги - что делел, что буду делать, какие проблемы
* демонстрация спринта (если нечего - смотрим на графики, где что-то пошло не так)
* ретроспектива спринта (начать с положительного, потом к отрицательному). Может быть переоценить стори, которые ошибочно оценены

Проект должен быть адаптивен, как и процесс разработки.
Мешают гибкости проекта
* жесткость
* нехватка абстракции
* слишком много абстракции
* смешанная обязанность
* неприспособленность к тестированию

# Введение в канбан
Канбан по-японски - вывеска
доска канбан - что делать | выполняется | закончено
сбор данных о процессе - 
|ждать | анализировать | реализовывать | проверить | поставить|
|------|---------------|---------------|-----------|----------|
|упорядочены по приоритету|добавление деталей к задаче, что надо сделать| реализация|тестирование|результат|
* каждая колонка можетбыть разбита на две части (написана документация | заверено)
* каждая колонка имеет лимит

## Две задачи в завершении разработки
* защита против изменений: не менять постановку в  момент реализации
* определение законченности
    * каждый последующий этап говорит о законченности предыдущего
* законченность спецификации
    * размер работ
    * ожидаемая функциональность
    * ситуации сбоя
* законченность кода
    * тесты 80%
    * существующие тесты не уменьшили покрытие
    * ревью
* законченность тестирования
    * автоматические проходят
    * нет багов
    * соответствует спецификации
    * регресс проходит
* совещания: если колонка выполняется пустая или пустой беклог. необходимо собрать ответственных, имеющих отношение к проблеме
* введение класса обслуживания - эти карточки должны разделяться на доске(баги, новый функционал)
* соглашение об уровне обслуживания: выделить количество дней на карточку + уровень доверия (50%). Нестрогий срок, но повод стремиться
* лимиты классов обслуживания: например, для задач рефакторинга
* время выполнения и время цикла -метрики работы команды
**время цикла** - время потраченное на выполнение задачи
**время выполнения** - время ожидания в беклоге  + время

Канбан лучше подходит для непрерывной поставки
**Скрам для новой команды, канбан для зрелой**

# Зависимости
В начале проекта скорость разработки может быть высокой, но если неправильный подходк зависимостям, то скорость начинает падать
**Зависимость** - соотношение между сущностями, при условии что одна не может выполнять действия без второй. 
A зависит от B, но B  не зависит от A - тип зависимости **Клиент-служба**(Основная зависимость)

Если зависимость не вызывается(используется какой-то метод), а просто есть(загружена), то исполняемая среда CLR  ее не загружает. using в начале файла не не герирует инструкции дял CLR и служет лишь синтаксическим сахаром

**Зависимости от инфраструктуры** (сборки Netcore, Framework) При загрузке инфраструктурной сборки она загружается в память раз для всех. Ссылка на инфраструктурную сборку всегда вызывает загрузку при запуске приложения, если сборка еще не загружена
**Сторонние зависимости** - зависимости внешних поставщиков.

Для моделирования зависимостей кода, хороши графы (стрелка от зависимого). Есть возможность обойти граф по ребрам. Если идти по одному из ребер и приходишь к себе же - это циклическая зависимость. Если зависишь сам от себя, получается петля, которая свидетельствует от рекурсии

## Управление зависимостями
* отказ от программирования на реализации в пользу интерфейсов в защиту сокрытия реализации
* new - признак плохого кода - это опускание в реализацию(конструктор):
    * получаем сложности модульного тестирования
    * невозможность улучшения реализаций (для клиентов нужно будет оставлять классы неизменяемыми)
    * цепочка зависимостей (зависимости от внутренних реализаций)
    * Решение: использование интерфейса, созданного в другой сборке, внедрение зависимостей

### Распознавание сборок
CLR - исполняющая среда, которая представляет собой виртуаотную машину для выполнения кода. Процесс распознавания сборок в Net Framework - Это процесс покрывающий разрыв  между добавлением ссылки на сборку в проекте и обеспечение работы с запущенной сборкой. 
* применение JIT(just in time) для распознавания сборок в момент задействия функций сборок
* сборка имеет идентичность (имя, версия, культура, маркер, открытого ключа)
* когда установлена идентичность, CLR  выясняет были ли попытки распознавания в текущем выполнении
    * если была, то используем загруженную сборку(если грузили, но получили ошибку, то даже не пытаемся загрузить)
    * если первая попытка: 
        * проверяется GAG - глобальный кеш сборок(хранилище сборок на уровне машины). если в нем нашли, что загружаем оттуда
        * если нет GAC просматриваются каталоги(app.config, codebase), если и тут нет, то bin
        * если нет значит распознавание потерпело неудачу

### Службы
Службы добавляют меньшую связность
Два способа создания службы
* Если адрес известен. Возможно добавление ссылки на службу с генерацией классов (WCF), которая создает прокси-класс службы. ну или написать прокси класс самомум
* Если адрес службы не известен. Возможно обращение через прокси к одному узлу, который перенаправляет запросы (UDP). Минус - единственная точка точка отказа, не гарантирует доставку сообщений
* служба **REST**. Очень низкие требования зависимости. HTTP запрос + правильная инструкция. Получается зависимость только инфраструктурная

### Управление зависимостями через nuget
если пользуемся собственными и внешними пакетами, лучше использовать Nuget, т.к помимо удобства получаем информацию, о внутренних зависимостях пакета

## Разделение на уровни
**Компонент** - группа из двух или более связных сборок.
**Разделение на уровни** - паттерн, который способствует восприятию компонентов, как горизонтальных уровней функциональности, основанных друг на друге с целью формирования полного приложения. Нижний уровень не имеет зависмостей, а внрхний звисит от нижнего, но не сквозная зависимость от нижнего, только -1

### Паттрены разделения на уровни
Чем больше сложность, тем больше уровней
Разница между уровнями и звеньями - это разница между логическим разделением и физическим развертыванием кода. Каждое новое звено - это пересечение границ сети(влечет издержки), но дает возможность к горизонтальному масштабированию
### Два уровня (UI -> доступ к данным)
#### Пользовательский интерфейс
Это способ взаимодействия с приложением
* отображение данных
* получение пользовательских требований
* проверка доставерности пользовательского ввода (JS, WPF, набор служб)
* пользовательский интерфейс должен обращаться к интерфейсам доступа к данным, но это по-прежнему два уровня

**Утечка абстракции - ссылка из верхнего уровня на реализацию нижнего уровня**

#### Доступ к данным
* Обслуживание запросов к данным
* сериализация и десериализация объектных моделей в и из доменной модели

Имееи источник хранения данных и слой доступа к ним (могут быть просто хранимки)
**Минусы** очевидны (смешение логики, сложность тестирования, сложность переиспользования)
**Плюсы** быстро

### Три уровня
Пользовательский интерфейс ->(вниз)бизнес-логика-> доступ к данным
**Бизнес-логика** 
* предоставляет интерфейсы доступа к нижнему слою
* обрабатывает команды UI
* моделирует предметную область для сбора бизнес-процессов, правил
* не должно быть зависимости от реализации (ORM, UI и т.д)

### Слабые обязанности
**Аспекты** - это применение сквозных обязанностей к множеству уровней кода. Например, аттрибуты логгирования и валидации

### Отделение команд от запросов
**CQRS (Command QUERY RESPONSIBILITY DEGREGATION)**
**CQS**- разделение команд и зпросов
**Команды** требуют от кода сделать что-нибудь. Они могут менять состояние системы. Команда не возвращает значения
**Запросы** заявки на данные, требующие получить что-нибудь

**Отделение обязанностей комманд и запрсоов.**
CQRS предполагает, что для наилучшей обработки команды или запрсосы могут нуждаться в следовании разным путям через уровни. Например три уровня для комманд и два для запросов. Для команд нужно обеспечивать acid (атомарность, согласованность, изоляцию, постоянство)

# Интерфейсы и паттерны проектирования
Помимо известного факта, определяющего интерфейс, как "определитель поведения", интерфейс определяется характеристиками, концепциями, которые он воплощает.
Сколько интерфейсов имеет смысл реализовывать классу, ведь количество неограниченно

**Множественно наследование было запрещено, потому что если один класс наследует больше одного класса, и они содержат идентичные методы, то какой должен применяться**

**Неявная реализация интерфейса** - это когда интерфейс опеределяется через член класса
**Явная реализация** - определение методов в классе

Пример: IListCopyTo 
```
public void CopyTo // явно реализовали метод
ICollection.CopyTo() // неявно
```
Явная реализация нужна, если несколько интерфейсов реализуемых классом имеют одинаковую сигнатуру. Для разделения каждого случая можно использовать для различения
```
void Interface1.Run()
void Interface2.Run()
```
В явной реализации методы приватны и доступны только после приведения к соответствующему интерфейсу, т.е после приведения к определенному типу вызовется нужное поведение для разных интерфейсов

## Полиморфизм
Мехнизм заставить объект одного типа неявно вести себя так же, как если бы относился к другому типу
Самое частое использование - единый интерфейс для разного типа классов (по поведению). Например, разные типы машин, но все долны уметь двигать колеса. Везде будет использоваться общий интерфейс , клиенту на надо знать деталей реализации.

## Адаптивные паттерны
### Паттерн null-object
Защита от nullReferenceException
* Подход позволяет убрать проверки на null. Вводим два класса null И стандартный, каждый из которых реализует интерфейс с общей логикой, только в null в некоторых местах общая логика пропущена и не вызывает ошибки. Возвращает объект общего интерфейса и для вызывающего метода и мы не полчаем ошибки. ПОдход частично заменен на T?, когда при null вызывается default(T), но не всегда удовлетворяем стандартным знаечниям

### Антипаттерн IsNull
Добавление в интерфейс метода bool IsNUll.
Проблема: выход логики за пределы объектов, в вызывающем объекте появляются if. Проблема исправляется паттерном выше

### Адаптер паттерн
Паттерн позволяет предоставить клиенту экземпляр класса, имеющего зависимость от интерфейса, котоырй класс не реализует. Класс адаптер соответствует определенному интерфесу, реализует эти методы за счет делегирования разным методам другого объекта

#### Адаптер класса
Подкласс(наследник) класса, адаптируется под нужды клиентов. Минус - зависимоть от реализации, видна реализация (белый ящик)
```
public class Adaptee 
{
    public void MethodB()
    {
    }
}

public class Adapter: Adaptee 
{
    public void MethodA()
    {
        MethodB()
    }
}
```

#### Адаптер объекта
Применение композиции, чтобы делегировать вызовы методов интерфейса, методом содержащегося в нем инкапсулированного объекта. Через конструктор внедрить другой класс. Внедренный класс выполняет все действия
```
static Interface dependency = new Adapter(new TargetClass())
```
### Паттерн стратегия
Паттерн демонстрирует разное повеление в зависимости от состояния объекта. Два класса реализуют один интерфейс. В вспомогательном классе на основе входного объекта вызывается нужная реализация. После во внешнем классе просто вызывается метод. Способ выбора стратегии - это дискуссионная деталь реализации

### Утиная типизация
Задействует "утиный тест". когда вижу птицу, которая плавает как утка, крякает как утка, то это утка.
**Правило** пока объект демонстрирует поведение опредленного интерфейса, он должен трактоваться как этот интерфейс
Для c# CLR, если методы совпадают с интерфейсом(класса), то объект не может считаться реализующим интерфейс.

Поддрержка утиной типизации в CLR работает в foreach. Если объект для foreach будет иметь GetEnumerator + возвращает объект, который имеет MoveNext и Current, тогда foreach пройдет.

### Примеси
**Примесь** - это класс, который содержит реализации множества других классов, не применяя наследование реализации
Расщиряющие классы, как пример примеси
Минусы:
* сложность модульного тестирования
* не хранит состояние экземпляра, связанного с объектом (из-за static)

Re-motion Re-miх, как пример примеси
Библиотека позволяет генерировать новый тип на лету, который удовлетворяет требованиям всех интерфейсов, присутствующих в запрощенных примесях, причем каждый экземпляр данного типав случае вызова метода интерфейса делегирует работу экземпляру примеси

### Текучие интерфесы
Это интерфейс, который возвращает себя из одного (или больше) методов. Это позволяет связывать вызовы в цепочки. Улучшает читабельность и позволяет реализовывать конфигурации или конечные автоматы. Любая цепочка обращений к методам останавливается вызовом метода, который не является текучимю 

**Интрефейсы - катализаторы полиморфизма. Корень паттернов**

# Тестирование
## Модульное тестирование
Составные части теста Паттерн AAA || Given When Then
* предусловие теста
* тестируемое действие
* утверждение о том, что ожидаемое поведение было продемонстрировано

**Организация(Given)** - инициализация нужного класса
**Действие(When)** - должно состоять из одного действия (метода, обращения к средству извлечения или установки свойства)
**Утверждение(Then)** - сравнение действительного и ожидаемого значения

## Разработка через тестирование
Тест формклирует через утверждения то, что производственный код должен действовать определенным образом. В идеале сначала тесты, потому код(реализация)

### Красный зеленый рефакторинг
* пишем отказывающий тест
* пишем метод, чтобы код проходил
* рефакторинг, если нужно
* помимо метода можно тестировать начальное состояние объекта (до выполнения метода)
* нужно думать есть ли еще тесты, способные сломать логику реализованную. 
* необходимо действовать из заложенной логики "в жизни" к тесту, к модулям

### Тестовые дублеры
* макеты(dummy) для создания списков параметров без специального поведения
* шпионы(spy) записывает вызовы, которые делались к методам. утверждения гарантируют, что метод был вызван
* заглушки(stub) заглушки для зависимостей, например, заглушки возвращают фиктивные данные
* подделки(fake) ручная имитация, близка я к реальному ответу(фейковый класс от коренного интерфейса). можно подсовывать как зависимость в нужный класс
* имитации(mock) тестовые дублеры зависимостей, имеющих непрямые команды. 

**Проблема. Чрезмерное определение тестов** - если у класса много зависимостей и он завимим от них, получаем зависимость теста от реализации, и тестируется не определенное поведение, а реализация. Тест чрезмерен, когда тесту известна реализация, а не ожидаемое поведение
**Решение** 
* тестировать полько поведение. Лучший пример такого теста, тест основанный на состоянии. Если метод принимает данные и возвращает измененные данные, то для тестирования это черный ящик. ПОзже метод может быть подвергнут рефакторингу, не нарушая прохождения модкльных тестов
* тестировать и писать мелкие тесты и реализации
* принять как факт связку теста и реализации и исправлять параллеьно

**Обработку исключений нужно прокидывать на новый уровень. И для каждого уровня свой тип исключения, иначе может быть зависимость между уровнями**

В тесте можно отлавливать исключения через catch, если исключение происходит на другом уровне - проверить тип exception

### Настройка тестов
Выделение ожиданий установок в специальные методы инициализации и завершения, которые вызываются соответственно в начале и конце каждого теста. Метод должен быть помечен [TestInitialize]

## Паттерны модульного тестирования
* первостепенное внимание согласованности (все в одном стиле)
* разумное соотношение между тестовыми остнастками и классами (1 тестовый класс  - 1 класс)
* именовнаие тестируемой системы (понятные имена свойств, методов, клссов)

### Паттерн строитель
Порождающий паттерн (полезен для инкапсуляции и абстрагирования создания объектов). Отличается от фабрики методом настройки объекта
```
interface IBuilder {void buildPart();}

class ConcreteBuilder : IBuilder {
    void buildPart()
    Product create()
}
```
Можно использовать этот паттерн для создания цепочки инструкций. Каждый из методов в классе-сборке для тестирования, реализующем строитель,возвращает реализацию IBuilder, т.е this. Поэмому в итоговом модульном тесте можно конфигурировать проверки. Порождает продукты для любых или всех поддерживаемых объектов
```
var unitclass = BuilderClass();
unitClass
.setup()
.adddatf()
.result()
```
## TDD (testing driving development)
**Идеальное** разработчики подходят к клавиатуре без обдумывания решения. Вместо этого готовят реализацию по мере движения. Движение направляется написанием отказывающих контрольных тестов.
**Прагматичное** просто пишем тесты по придуманой в голове реализации(или уже готовой) **TFD**(test first development)

**TDD**
* пишем неработающий тест (без целевых работающих методов) - отталкиваясь от задачи
* чиним тест (реализованные методы)
* проводим рефакторинг, если необходим (новый абстракции, декомпозиция, извлечение методов)
* создать класс
* напсиать новый тест

**TFD**
Все уже спроектировано на бумаге(в голове). Поведение нужно просто реализовать

**TDD порождает достаточный проект**
**TDD порождает любой проект, который возникает в голове разработчика**

### Добавочное тестирование
**Пирамида тестирования** 

                      /\  РУЧНОЕ
                    /    \
                  / ______ \
                / ПРИЕМОЧНЫЕ \ автотесты, повторение действий пользователей (на стенде) 
              /  _________     \
            /   ИНТЕГРАЦИОННЫЕ   \ тесты API интерфейса, где служба, как черный ящик
          / _________________      \
        /          МОДУЛЬНЫЕ         \
        --------------------------  
Каждый уровень пирамидыуказывает, что один ярус должен быть меньше другого

**Антипаттерны**
* песочные часы МОДУЛЬНЫЕ - интеграционные(мало) - ПРИЕМОЧНЫЕ
* рожок модульные - интеграционные - ПРИЕМОЧНЫЕ - признак спутанного нетестируемого кода, поэтому покрыты внешними

### Тестирование для профилактики проблемй
Доверие - в нем ценность тестов
Неудача - лучший учитель
Нужно сместить внимание со средней наработки на отказ (Mein Tain Before failure)  в сторону среднего времени восстановлениея (Mein Time ToRecovery). MTTR - не только допускает отказ, но и готов к нему

# Рефакторинг
**Рефаторинг** - это процесс улучшения текущего кода, рефакторинг меняет организацию кода, а не его исход
* замена магических чисел на константу (понятное имя). Значение 0 и 1 необязательно заменять
* замена условного выражения полиморфизмом (switch можно заменить состянием, стратегией, и т.д), ну или наследованием 
* замена конструктора фабричным методом
    Через Switch в методе базового класса Create(Type type) - выбираем нужную реализацию через new. Фабричный метод статический. Запрет классам создавать экземпляры классов
* замена логики конструктора фабричным классом
    * сделать фабрику с методом create
    * внедрим фабрику в нужный класс
    * передаем фабрике тип нужного экзампляра
* замена реализации New в методе фабрики через рефлексию и создание экземпляра на основании названия. Activator.CreateInstance. Минус - должны быть выполнены соглашения
* плохой код "отказ от наследства" - стандартное поведение реализует родительский класс. Лучше создать специальный класс без поведения.
* замена наследования делегированием
    Передача полномочий выходящих за пределы класса другим классам, в внутрь себя внедрять через конструктор

## Из рефакторинга к перепроектирвоанию
**Перепроектирование** - это рефаторинг с учетом новых требований и функционала. В итоге перепроектирования будут меняться и модульные тесты. Сначала меняет тесты, котом код

### Превращение унаследованного кода в адаптивный
Унаследованный код (легаси) - это код без тестов. Как работать с таким кодом.
* тесты характеристики. Цель сбор данных об особенностях выполнения кода(журналы). Журналы - это основа для утверждения тестов
* золотой мастер - сравнивает результаты тестов с тем, что выдают характеристики. Обрабатывает выходной файл характеристик и применяет их в качестве утверждений. Файл характеристик может сгенерировать и как консольное выражение, и как подробные логи с выходными и входными параметрами

# SOLID 
## Принцип единичной ответственности(SRP)
Этапы разделения большого класса (с многими обязанностями)
* разделение на методы меньших размеров, каждый из которых основан на единичной обязанности
* делегировани внутри метода. Рефаторинг для ясности обязанностей других методов

### Рефаторинг для абстрагиварония
* выделение интерфейсов для общей цели
    * у одного класса не должно быть прямых зависимостей от реализации класса, а вместо этого нужно работать с интерфейсами
    * **класс, который будет обрабатывать все вызовы от интерфейсов тоже будет иметь одну обязанность - изолирование процесса**
    * моделирование процесса вокруг одной сущности

Все инттерфейсы должны находиться в одной сборке, а значит будет существовать клиентская сборка и сборка реализаций, которые не будут ссылаться друг на друга

Помимо стандартного IClass и Class - реализующий интерфейс, можно назвать класс BookClass, как бы указывая специфику реализации

Все классы, которые зависят от какой-то сборки(внутренней) или стали зависеть - должны быть выделены в отдельную сборку.

Процесс такого рефакторнга рекурсивен. В процессе инспектирования класса устанавливаются обязанности и выделяются, пока обязанность не останется одна.

**В процессе рефакторинга золотой тест должен проходить**

### SPR и декоратор
Предпосылка использования: каждый класс декоратора удовлетворяет контракту типа и принимает один или более типов в качестве параметров конструктора
```
interface IClass{
    void Doing ();
}

class Class1: ICLass {
    condtructor(IClass class) {}
    void Doing() {
        action();
        class.Doing()
    }
}
```

### SPR и компановщик
Это специализация паттерна Декоратор и одно из частых употреблений паттерна декоратор.
**цель паттерна** трактовать множество экземпляров реализацииинтерфейса, как если бы они были одним экземпляром
```
interface IClass {
    void Doing();
}
class Class1: IClass {Doing();}
class Class2: IClass {Doing();}

class CompositeComponent: IClass {
    public CompositeComponent() {
        children = new List<IClass>()
    }
    void Add(Iclass class) {
        children.add(class)
    }
    void Remove(Iclass class) {
        children.Remove(class)
    }
    
    void Doing() {
        foreach (var child in children){
            child.Doing()
        }
    }
}

class Program {
    void Main() {
        var composite = new CompositeComponent();
        composite.Add(new Class1())
        composite.Add(new Class2())
        composite.Doing()
    }
}
```
### Предикатный декоратор
КОнструкция для сокрытия условного выполнения кода от клиентов. Условное выражение выносится в отдельный интерфейс и внедряется через конструкторв. Остается только вызвать метод (проверка, например)

### Разветвляющий декоратор
Это возможность использовать разные варианты выполнения (например для true false) и проверки для разных веток. Два внедренных алгоритма для двух условий

### Ленивые декораторы
через конструктор внедряется Lazy<IClass> и возвращает при выполнении действия doing(). Это обертка вокруг компонента IClass/

### Регистрирующие декораторы
Использование обертки вокруг исходного интерфейса для записи в логи. Передача исходного класса через конструкттор

### Профилирующие декораторы
Внедряем внутрь через конструктор экземпляр интегрирующий и обернуть таймером. Таймер можно вынести в отдельный класс.

### Декорирование свойств и событий
Вызов внутри свойства испходного класса значния внедренного класса

## Принцип открытости-закрытости (OCP)
Первое определение(Мейер): сущности открыты для расширения, но закрыты для модиыикации
Определение Фаулера: определение модулей соотвествующих принципам OCP
* **открыто для расширения** - поведение может быть расширено. При изменении требований модуль может быть расширен новыми линиями поведения, удовлетворяющие необходимым изменениям. Иначе, возможность добавть новое то, что делает модуль
* **закрыты для модификации** - расширение модуля не ведет к изменениями в исходном коде или двоичном коде модуля. Конечная версия модкля остается нетронутой (dll, jar)

Пункт закрыты для модификации не работает в двух случаях
* исправление деффектов (если про чистоту - создается новый класс)
* осведомленность клиентов (если клиентам не нужно менять код, то менять, модифицировать модуль можно)

### Открыты для расширения
Варианты точек расширения:
* код без точек расширения. если class1 зависит от class2 и появляется новое требование, в результате которых нужно внести изменения в class2. не имея возможности поменять class1, создается class3, а значит в class1 меняем только ссылкуна используемый метод(если разрешаем вносить изменения без изменения клиентов,то можно менять). Это получается из-за сильной связности

### Виртуальные методы
Если метод в class2 является виртуальным, то он открыт для расширения через наследование реализации. Тогда class1 в изменении может не нуждаться, т.к можно создать в классе class 2 подкласс и изменить в нем необходимый метод. можно снабдить class1 новой версией class2 клиента и подсунуть реализауию подкласса.
**Минусы** имеется доступ к базовому классу class1.method1(), но изменять отдельные строчки метода нельзя. Код вызывается целиком с добавлением новой функциональности до или после вызова, либо реализуется заново.

**Подклассы могут обращаться только к тем членам базового класса, которые помечены как protected**

### Астрактные методы
Class2 абстрактный класс. Клиент зависит от абстрактного класса, поэтому может вызывать любой измреализующих классов. class4(старая реализация) или class5(новая). Помогает в этом шаблонный метод: моделируется алгоритм, шаги которого допускают настройку благодаря делегированию абстрактным методам.

### Интерфейс
Наследование от класса заменяется делегированием интерфейсу. При наследовании реализации все подклассы - клиенты абстрактного класса, что мешает модификации. Значит клиенты всегда нуждаются в изменении реализации. Изменение в одном звене иерархии клияет на всех участников. Интерфейсы можно декорировать, лечге строить композицию.

**Проектируйте наследование, если оно точка расщирения или запретите его**
**sealed - запрет на наследование**

## Закрытость к модификации
Принцип для помощи в поиске границ принципа открытости-закрытости
* идентифицируйте места предстказуемых изменений и создайте вокруг них стабильный интерфейс
* **предсказуемые изменения**: необходимо выяснить у заказчика о возможных изменениях проектируемого и реализуемого функционала.
* **стабильный интерфейс**:  вероятность и частота изменения интерфейса должна быть минимальной, иначе придется вносить изменения во все клиенты
* только достаточная степень адаптации.
* избегать божественных объектов
* Точка расширения, просто, как точка расширения. Этот пункт о разумности повсеместного выделения интерфейсов и поиск компромисов
* предсказуемые изменения (добавление предположительных методов расширения) или гипотетическое обобщение (избегать попыток придумывания, что будет делать класс). Истина где-то посередине

# Принцип подстановки лисков (LSP liskovs ubstitution principe)
Это набор указаний для создания иерархии наследования, в которых клиент может надежно пользоваться любым классом или подклассом.
* если не союлюдаются правила, то расширение иерархии классов может повлечь изменения в любом клиенте базового класса или интерфейса

Определение если S подтип Т, тогда объекты типа T могут быть заменены объектами типа S? yt yfheifz hf,jns ghjuhfvvs
**Базовый тип** - это тип, на который клиенты имеют ссылку
**Подтип** - любое возможное семейство классов, унаследованное от базового
**Контекст** - способ взаимодействия клиента с подтипом

**Правила LSP**
* предусловия не могут быть усилены в подтипах
*  постусловия не могут быть ослаблены в подтипе
*  инварианты супертипа (условия, которые должны оставаться истинными) должны быть сохранены в подтипе

**Правила вариантности**(вариантность аргументов и выходных типов)
* в подтипе должна существовать контрвариантность аргументов методов
* в подтипе должна существовать ковариантность возвращаемых типов
* в подтипе нельзя генерировать новые исключения, если они не принадлежат существующей иерархии исключений

Программисты должны программировать на основе интерфейсов(программировать на основе контрактов)
Со стороны сигнатуры методов контракты должны иметь понятные имена, понятные параметры. Если на парметр накладываются условия(например > 0) тогда в методе должно существовать предусловие

**Предусловия** - можно реализовать за счет замкнутой конструкции в начале метода и вернуть исключение в случае ошибки. Предусловие должно быть очевидным и зависеть от того, что передал клиент.

**Постусловия** - проверяют остался ли объект после выполнения метода в допустимом состоянии. Проверка в конце метода.

**Инварианты данных** - предикат, который остается истинным для всего времени жизни объекта. Он становится истинным в момент конструирования объекта и неизменям до конца жизни. Например, установка значения через конструктор.

**Предусловия не могут быть усилены**
Когда в подклассе переопределяется существующий метод, который содержит предусловия, никогда нельзя усиливать предусловия. Это может нарушить работу клиентов, которые сущуствуют с текущим условием. Например, в дочернем классе появляется правило для параметра, что он не должен быть null. Мы переопределяемметод и в немзаписываем условие, получаем: для базового класса можно передавать null, а в дочерный нет. Клиент не должен быть осведомлен, какую из реализаций он использует

**Постусловия не могут быть ослаблены**
Та же история, но клиент уже зависит от результата и может ожидать одного поведения, а получить другое (например не ожидает Null, а пришел null)

**Инварианты должны быть сохранены**
Инварианты должны быть неизменны во всей иерархии. Варинт использования: наследуемся в конструкторе через base(value) -> расширяем класс свойством, имеющим доступ к переменной. Можно попробовать предохранить инваринт, запретив изменять через свойство в исходном классе.

**Контракты кода**
* предусловия через Contract.Requires
* посусловия Contract.Ensures - принимает предикат, который должен быть истинным
* инварианты вместо условия в совйстве

Перехват исключения не должен делать клиент, т.к это значит, что они могут восстановиться после перехвата

## Ковариантность и контрвариантность
**Вариантность** - ожидаемое поведение подтипов и иерархии классов.
ко - "C" взаимосвязь друг с другом
контр - "против" подтипы идут друг против друга

**Ковариантность**
ПОлиморфизм - это способность типа трактоваться так, если бы он был экземпляром супертипа
В C# любой тип принимающий 
```
SuperType {field1, field2, Method1(), Method2()}
```
способен принять
```
SubType {field1, field2, field3, Method1(), Method2(), Method3()}
```
без приведения, требуемого со стороны клиента или службы.
Для обобщенных типов ICovariant<out T>, поэтому если нужен супертип, можно подсунуть SubType - это совместное функционирование полиморфизма и ковариантности.

При отсутсвии обобщенных типов не поддерживается ковариантность для возвращаемых типов метода.

**Проверить вернуть override не тип, который возвращает в virtual**

**Контрвариантность**
Контрвариантность касается типов на вход, тогда как ковариантность на выход IContrVariant<in T>.
Примером служит обратная иерархия наследования.
```IContrVariant<SubType> -> над -> IContrVariant<SuperType>```
Без контрвариантности: метод ```Equals(User1 user1, User2 user2)``` не может быть выполнен при вызове ```Equals(Entity1 user1, Entity2 user2)```. Никакого преобразования Entity в User не может, так как User это подтип, но подключая контрвариантность (in) мы может инвертировать иерархию.

**Инвариантные типы(не вариантные)**
Нет возможности манипулировать с преобразованием типов
Вернемся к принципам лисков
* контрвариантность аргументов
* ковариантность возвращаемых типов

новые исключения не разрешены: исключения нужны для определения ошибки от обработки. Обработка ошибок и их сообщения деляются в разных классах с разными целями и контекстами

любоц код может генерировать исключения, перехватывать и делегировать.
Правило: 
* перехватываем там, где можно сделать что-то занчимое(откат транзакции, отправка сообщения об ошибке)
* нежелательно перехватывать исключение общего типа exception или ничего не делать
* нежелательно перехватывать и осмыслять исключения всех типв. Можно улучшить дело созданием собственных исключений. Но это препятствует единственному блоку catch и клиету надо знать обо всех типах исключений, но нельзя прибегать к Exception. Вместо этого можно создать базовый класс исключения с необходимой информацией об ошибке.

**Любое нарушение LSP - технический долг**

# Разделение интерфеса
Все члены интерфейса должны быть релаизованы, но если каждый клиент не должен этого делать, не нужно навязывать эту зависимость
Рассмотрим пример сервиса с GRUD операциями(обобщенный интерфейс и реализация).
* при использовании декораторов, например, нужно првоерить согласие(или кешировать) в какой-то операции, а все остальные методы вызываются "сквозным методом"(просто вызываются). Имеет смысл выделить сложную операцию в отдельный интерфейс
* объединить отдельный интерфейс с операцией сохрания(получения)

**Декорировани множества интерфесов**
Необходимо использовать паттерн адаптер и декоратор, чтобы создавать множество декораторов, сводя к минимуму объем кода. Одиночный класс может быть реализацией для множества декораторов, но если контекст декоратора используется совместно(одно действие в каждой реализации "функциональное")

**Пострование клиентов**
* Множество релаизаций, множество экземпляров. Ождин клиент зависит от нескольких обобщенных интерфесов. Можно сделать этот клиент(контроллер, хендлер) обобщенным, если это необходимо(например использоваться только одна базовая сущность)
* единственная реализация, единственный экземпляр.
    Объединить все интерфесы в один класс. Даже объединив их есть плюсы: контроллер будет создавать реализацию класса, не зная, что внутри. контроллер будет строиться как new controller(crud1, crud2, crud3). Это антипаттерн каша из интерфейсов. Объединение всех интерфейсов сводит на нет, все преимущества интерфейсов.

**Разделение интерфейсов**
* потребность клиента, клиент создает только то, что нужно
* функциональность. Защитить части от неправильного использования, например для CQR
* авторизация. Разделения для авторизованного и неавторизованного пользователя
* архитектурная потребность. Например, определенные требования предъявляет CQRS(чтение -mongo, запись - sql store)
* интервеймы часто выделяют как крупные фасады, за которыми крупные подсистемы, которые в последствии теряют способность к адаптации






















