# Адаптивный код
# Введение в скрам
Scrum - это гибкая методология управления проектами, ценность которой в итеративности
**Гибкая метеодология разработки требует гибкого кода, иначе вносимые изменения будет всем сложнее и медленнее**

Водопад не подразумевает движения в обратном направлении, т.е если завершили разработку и споткнулись на тестировании - путей обратно нет и получается комок грязи из исполнителей. Водопад не предполагает изменений или изменения избегаются

Скрам подразумевает, что изменения неизбежны и процесс построен так, чтобы учитывать адаптивность к изменениям

**Цель:** Писать код адаптивный к изменениям

В водопаде акцент на документацию, в скраме на ПО

## Роли
* владелец продцкта (связь с заказчиком, приоритеты, оценка следования требованиям)
* скрам-мастер (организация работы по скраму, защита от изменения спринта сверху)
* разработчики (специалисты, реализующие цели спринта)

## Артефакты
* Доска Scrum (реальная доска)
    * карточки для разных задач с разным цветом
        * зеленые - функциональные средства
        * белые - истории
        * желтые - задачи
        * красные - баги
        * фиолетовые - тех.долг
    * иерархия композиции - связи между карточками
    * продукт - что должно быть сделано
    * релиз - версия
    * функциональное средство. могут быть обязательные, предпочтительные, желательные
    * пользовательская история (формируется так (как, что, что сделать, когда)) анализируется, разбивается на задачи
    * задача - часть истории на конкретном разработчике
    * техдолг
    * баг
* беклог - упорядочен по приоритету
* тестирование
Горизонтальные дорожки для группирования по функциональному средству(истории с свамого верха, может быть дорожка для самых важных задач)

## Технический долг
Квадрат технической задолжности
|опреметчивая|благоразумная|
|------------|-------------|
|нет время на проектирвоание|выполним поставку, потом займется последствиями|

|неумышленная|благоразумная|
|------------|-------------|
|мы не знаем, что это такое, если бы мы знали, что это такое. ООП| мы знаем как должны были сделать

## Опредление законченности
Признаки:
* прошли модульные тесты
* прошло интеграционное тестирование
* корректное поведение по тест-куйсам
* прошло 

## Скорость
Скорость команды можно вычсилить после нескольких спринтов. Измерить в сторипоинтах. В дальнейшем скорость можно анализировать для оценки качества планирования

## Беклог
Беклог продукта: приоритет - это ценность задачи (функционального средства)
Беклог спинта - стори, которын долюны реализовать в спринте. Оценивается командой

## Спринт
Лучший запуск - середина недели
Планирование:
* определяется дата, приоритеты, функциональные средства
* покер (оценка стори в масштабе - числа фибоначи)
* митинги - что делел, что буду делать, какие проблемы
* демонстрация спринта (если нечего - смотрим на графики, где что-то пошло не так)
* ретроспектива спринта (начать с положительного, потом к отрицательному). Может быть переоценить стори, которые ошибочно оценены

Проект должен быть адаптивен, как и процесс разработки.
Мешают гибкости проекта
* жесткость
* нехватка абстракции
* слишком много абстракции
* смешанная обязанность
* неприспособленность к тестированию

# Введение в канбан
Канбан по-японски - вывеска
доска канбан - что делать | выполняется | закончено
сбор данных о процессе - 
|ждать | анализировать | реализовывать | проверить | поставить|
|------|---------------|---------------|-----------|----------|
|упорядочены по приоритету|добавление деталей к задаче, что надо сделать| реализация|тестирование|результат|
* каждая колонка можетбыть разбита на две части (написана документация | заверено)
* каждая колонка имеет лимит

## Две задачи в завершении разработки
* защита против изменений: не менять постановку в  момент реализации
* определение законченности
    * каждый последующий этап говорит о законченности предыдущего
* законченность спецификации
    * размер работ
    * ожидаемая функциональность
    * ситуации сбоя
* законченность кода
    * тесты 80%
    * существующие тесты не уменьшили покрытие
    * ревью
* законченность тестирования
    * автоматические проходят
    * нет багов
    * соответствует спецификации
    * регресс проходит
* совещания: если колонка выполняется пустая или пустой беклог. необходимо собрать ответственных, имеющих отношение к проблеме
* введение класса обслуживания - эти карточки должны разделяться на доске(баги, новый функционал)
* соглашение об уровне обслуживания: выделить количество дней на карточку + уровень доверия (50%). Нестрогий срок, но повод стремиться
* лимиты классов обслуживания: например, для задач рефакторинга
* время выполнения и время цикла -метрики работы команды
**время цикла** - время потраченное на выполнение задачи
**время выполнения** - время ожидания в беклоге  + время

Канбан лучше подходит для непрерывной поставки
**Скрам для новой команды, канбан для зрелой**

# Зависимости
В начале проекта скорость разработки может быть высокой, но если неправильный подходк зависимостям, то скорость начинает падать
**Зависимость** - соотношение между сущностями, при условии что одна не может выполнять действия без второй. 
A зависит от B, но B  не зависит от A - тип зависимости **Клиент-служба**(Основная зависимость)

Если зависимость не вызывается(используется какой-то метод), а просто есть(загружена), то исполняемая среда CLR  ее не загружает. using в начале файла не не герирует инструкции дял CLR и служет лишь синтаксическим сахаром

**Зависимости от инфраструктуры** (сборки Netcore, Framework) При загрузке инфраструктурной сборки она загружается в память раз для всех. Ссылка на инфраструктурную сборку всегда вызывает загрузку при запуске приложения, если сборка еще не загружена
**Сторонние зависимости** - зависимости внешних поставщиков.

Для моделирования зависимостей кода, хороши графы (стрелка от зависимого). Есть возможность обойти граф по ребрам. Если идти по одному из ребер и приходишь к себе же - это циклическая зависимость. Если зависишь сам от себя, получается петля, которая свидетельствует от рекурсии

## Управление зависимостями
* отказ от программирования на реализации в пользу интерфейсов в защиту сокрытия реализации
* new - признак плохого кода - это опускание в реализацию(конструктор):
    * получаем сложности модульного тестирования
    * невозможность улучшения реализаций (для клиентов нужно будет оставлять классы неизменяемыми)
    * цепочка зависимостей (зависимости от внутренних реализаций)
    * Решение: использование интерфейса, созданного в другой сборке, внедрение зависимостей

### Распознавание сборок
CLR - исполняющая среда, которая представляет собой виртуаотную машину для выполнения кода. Процесс распознавания сборок в Net Framework - Это процесс покрывающий разрыв  между добавлением ссылки на сборку в проекте и обеспечение работы с запущенной сборкой. 
* применение JIT(just in time) для распознавания сборок в момент задействия функций сборок
* сборка имеет идентичность (имя, версия, культура, маркер, открытого ключа)
* когда установлена идентичность, CLR  выясняет были ли попытки распознавания в текущем выполнении
    * если была, то используем загруженную сборку(если грузили, но получили ошибку, то даже не пытаемся загрузить)
    * если первая попытка: 
        * проверяется GAG - глобальный кеш сборок(хранилище сборок на уровне машины). если в нем нашли, что загружаем оттуда
        * если нет GAC просматриваются каталоги(app.config, codebase), если и тут нет, то bin
        * если нет значит распознавание потерпело неудачу

### Службы
Службы добавляют меньшую связность
Два способа создания службы
* Если адрес известен. Возможно добавление ссылки на службу с генерацией классов (WCF), которая создает прокси-класс службы. ну или написать прокси класс самомум
* Если адрес службы не известен. Возможно обращение через прокси к одному узлу, который перенаправляет запросы (UDP). Минус - единственная точка точка отказа, не гарантирует доставку сообщений
* служба **REST**. Очень низкие требования зависимости. HTTP запрос + правильная инструкция. Получается зависимость только инфраструктурная

### Управление зависимостями через nuget
если пользуемся собственными и внешними пакетами, лучше использовать Nuget, т.к помимо удобства получаем информацию, о внутренних зависимостях пакета

## Разделение на уровни
**Компонент** - группа из двух или более связных сборок.
**Разделение на уровни** - паттерн, который способствует восприятию компонентов, как горизонтальных уровней функциональности, основанных друг на друге с целью формирования полного приложения. Нижний уровень не имеет зависмостей, а внрхний звисит от нижнего, но не сквозная зависимость от нижнего, только -1

### Паттрены разделения на уровни
Чем больше сложность, тем больше уровней
Разница между уровнями и звеньями - это разница между логическим разделением и физическим развертыванием кода. Каждое новое звено - это пересечение границ сети(влечет издержки), но дает возможность к горизонтальному масштабированию
### Два уровня (UI -> доступ к данным)
#### Пользовательский интерфейс
Это способ взаимодействия с приложением
* отображение данных
* получение пользовательских требований
* проверка доставерности пользовательского ввода (JS, WPF, набор служб)
* пользовательский интерфейс должен обращаться к интерфейсам доступа к данным, но это по-прежнему два уровня

**Утечка абстракции - ссылка из верхнего уровня на реализацию нижнего уровня**

#### Доступ к данным
* Обслуживание запросов к данным
* сериализация и десериализация объектных моделей в и из доменной модели

Имееи источник хранения данных и слой доступа к ним (могут быть просто хранимки)
**Минусы** очевидны (смешение логики, сложность тестирования, сложность переиспользования)
**Плюсы** быстро

### Три уровня
Пользовательский интерфейс ->(вниз)бизнес-логика-> доступ к данным
**Бизнес-логика** 
* предоставляет интерфейсы доступа к нижнему слою
* обрабатывает команды UI
* моделирует предметную область для сбора бизнес-процессов, правил
* не должно быть зависимости от реализации (ORM, UI и т.д)

### Слабые обязанности
**Аспекты** - это применение сквозных обязанностей к множеству уровней кода. Например, аттрибуты логгирования и валидации

### Отделение команд от запросов
**CQRS (Command QUERY RESPONSIBILITY DEGREGATION)**
**CQS**- разделение команд и зпросов
**Команды** требуют от кода сделать что-нибудь. Они могут менять состояние системы. Команда не возвращает значения
**Запросы** заявки на данные, требующие получить что-нибудь

**Отделение обязанностей комманд и запрсоов.**
CQRS предполагает, что для наилучшей обработки команды или запрсосы могут нуждаться в следовании разным путям через уровни. Например три уровня для комманд и два для запросов. Для команд нужно обеспечивать acid (атомарность, согласованность, изоляцию, постоянство)

# Интерфейсы и паттерны проектирования
Помимо известного факта, определяющего интерфейс, как "определитель поведения", интерфейс определяется характеристиками, концепциями, которые он воплощает.
Сколько интерфейсов имеет смысл реализовывать классу, ведь количество неограниченно

**Множественно наследование было запрещено, потому что если один класс наследует больше одного класса, и они содержат идентичные методы, то какой должен применяться**

**Неявная реализация интерфейса** - это когда интерфейс опеределяется через член класса
**Явная реализация** - определение методов в классе

Пример: IListCopyTo 
```
public void CopyTo // явно реализовали метод
ICollection.CopyTo() // неявно
```
Явная реализация нужна, если несколько интерфейсов реализуемых классом имеют одинаковую сигнатуру. Для разделения каждого случая можно использовать для различения
```
void Interface1.Run()
void Interface2.Run()
```
В явной реализации методы приватны и доступны только после приведения к соответствующему интерфейсу, т.е после приведения к определенному типу вызовется нужное поведение для разных интерфейсов

## Полиморфизм
Мехнизм заставить объект одного типа неявно вести себя так же, как если бы относился к другому типу
Самое частое использование - единый интерфейс для разного типа классов (по поведению). Например, разные типы машин, но все долны уметь двигать колеса. Везде будет использоваться общий интерфейс , клиенту на надо знать деталей реализации.

## Адаптивные паттерны
### Паттерн null-object
Защита от nullReferenceException
* Подход позволяет убрать проверки на null. Вводим два класса null И стандартный, каждый из которых реализует интерфейс с общей логикой, только в null в некоторых местах общая логика пропущена и не вызывает ошибки. Возвращает объект общего интерфейса и для вызывающего метода и мы не полчаем ошибки. ПОдход частично заменен на T?, когда при null вызывается default(T), но не всегда удовлетворяем стандартным знаечниям

### Антипаттерн IsNull
Добавление в интерфейс метода bool IsNUll.
Проблема: выход логики за пределы объектов, в вызывающем объекте появляются if. Проблема исправляется паттерном выше

### Адаптер паттерн
Паттерн позволяет предоставить клиенту экземпляр класса, имеющего зависимость от интерфейса, котоырй класс не реализует. Класс адаптер соответствует определенному интерфесу, реализует эти методы за счет делегирования разным методам другого объекта

#### Адаптер класса
Подкласс(наследник) класса, адаптируется под нужды клиентов. Минус - зависимоть от реализации, видна реализация (белый ящик)
```
public class Adaptee 
{
    public void MethodB()
    {
    }
}

public class Adapter: Adaptee 
{
    public void MethodA()
    {
        MethodB()
    }
}
```

#### Адаптер объекта
Применение композиции, чтобы делегировать вызовы методов интерфейса, методом содержащегося в нем инкапсулированного объекта. Через конструктор внедрить другой класс. Внедренный класс выполняет все действия
```
static Interface dependency = new Adapter(new TargetClass())
```
### Паттерн стратегия
Паттерн демонстрирует разное повеление в зависимости от состояния объекта. Два класса реализуют один интерфейс. В вспомогательном классе на основе входного объекта вызывается нужная реализация. После во внешнем классе просто вызывается метод. Способ выбора стратегии - это дискуссионная деталь реализации

### Утиная типизация
Задействует "утиный тест". когда вижу птицу, которая плавает как утка, крякает как утка, то это утка.
**Правило** пока объект демонстрирует поведение опредленного интерфейса, он должен трактоваться как этот интерфейс
Для c# CLR, если методы совпадают с интерфейсом(класса), то объект не может считаться реализующим интерфейс.

Поддрержка утиной типизации в CLR работает в foreach. Если объект для foreach будет иметь GetEnumerator + возвращает объект, который имеет MoveNext и Current, тогда foreach пройдет.

### Примеси
**Примесь** - это класс, который содержит реализации множества других классов, не применяя наследование реализации
Расщиряющие классы, как пример примеси
Минусы:
* сложность модульного тестирования
* не хранит состояние экземпляра, связанного с объектом (из-за static)

Re-motion Re-miх, как пример примеси
Библиотека позволяет генерировать новый тип на лету, который удовлетворяет требованиям всех интерфейсов, присутствующих в запрощенных примесях, причем каждый экземпляр данного типав случае вызова метода интерфейса делегирует работу экземпляру примеси

### Текучие интерфесы
Это интерфейс, который возвращает себя из одного (или больше) методов. Это позволяет связывать вызовы в цепочки. Улучшает читабельность и позволяет реализовывать конфигурации или конечные автоматы. Любая цепочка обращений к методам останавливается вызовом метода, который не является текучимю 

**Интрефейсы - катализаторы полиморфизма. Корень паттернов**

# Тестирование
## Модульное тестирование
Составные части теста Паттерн AAA || Given When Then
* предусловие теста
* тестируемое действие
* утверждение о том, что ожидаемое поведение было продемонстрировано

**Организация(Given)** - инициализация нужного класса
**Действие(When)** - должно состоять из одного действия (метода, обращения к средству извлечения или установки свойства)
**Утверждение(Then)** - сравнение действительного и ожидаемого значения

## Разработка через тестирование
Тест формклирует через утверждения то, что производственный код должен действовать определенным образом. В идеале сначала тесты, потому код(реализация)

### Красный зеленый рефакторинг
* пишем отказывающий тест
* пишем метод, чтобы код проходил
* рефакторинг, если нужно
* помимо метода можно тестировать начальное состояние объекта (до выполнения метода)
* нужно думать есть ли еще тесты, способные сломать логику реализованную. 
* необходимо действовать из заложенной логики "в жизни" к тесту, к модулям

### Тестовые дублеры
* макеты(dummy) для создания списков параметров без специального поведения
* шпионы(spy) записывает вызовы, которые делались к методам. утверждения гарантируют, что метод был вызван
* заглушки(stub) заглушки для зависимостей, например, заглушки возвращают фиктивные данные
* подделки(fake) ручная имитация, близка я к реальному ответу(фейковый класс от коренного интерфейса). можно подсовывать как зависимость в нужный класс
* имитации(mock) тестовые дублеры зависимостей, имеющих непрямые команды. 

**Проблема. Чрезмерное определение тестов** - если у класса много зависимостей и он завимим от них, получаем зависимость теста от реализации, и тестируется не определенное поведение, а реализация. Тест чрезмерен, когда тесту известна реализация, а не ожидаемое поведение
**Решение** 
* тестировать полько поведение. Лучший пример такого теста, тест основанный на состоянии. Если метод принимает данные и возвращает измененные данные, то для тестирования это черный ящик. ПОзже метод может быть подвергнут рефакторингу, не нарушая прохождения модкльных тестов
* тестировать и писать мелкие тесты и реализации
* принять как факт связку теста и реализации и исправлять параллеьно

**Обработку исключений нужно прокидывать на новый уровень. И для каждого уровня свой тип исключения, иначе может быть зависимость между уровнями**

В тесте можно отлавливать исключения через catch, если исключение происходит на другом уровне - проверить тип exception

### Настройка тестов
Выделение ожиданий установок в специальные методы инициализации и завершения, которые вызываются соответственно в начале и конце каждого теста. Метод должен быть помечен [TestInitialize]

## Паттерны модульного тестирования
* первостепенное внимание согласованности (все в одном стиле)
* разумное соотношение между тестовыми остнастками и классами (1 тестовый класс  - 1 класс)
* именовнаие тестируемой системы (понятные имена свойств, методов, клссов)

### Паттерн строитель
Порождающий паттерн (полезен для инкапсуляции и абстрагирования создания объектов). Отличается от фабрики методом настройки объекта
```
interface IBuilder {void buildPart();}

class ConcreteBuilder : IBuilder {
    void buildPart()
    Product create()
}
```
Можно использовать этот паттерн для создания цепочки инструкций. Каждый из методов в классе-сборке для тестирования, реализующем строитель,возвращает реализацию IBuilder, т.е this. Поэмому в итоговом модульном тесте можно конфигурировать проверки. Порождает продукты для любых или всех поддерживаемых объектов
```
var unitclass = BuilderClass();
unitClass
.setup()
.adddatf()
.result()
```
## TDD (testing driving development)
**Идеальное** разработчики подходят к клавиатуре без обдумывания решения. Вместо этого готовят реализацию по мере движения. Движение направляется написанием отказывающих контрольных тестов.
**Прагматичное** просто пишем тесты по придуманой в голове реализации(или уже готовой) **TFD**(test first development)

**TDD**
* пишем неработающий тест (без целевых работающих методов) - отталкиваясь от задачи
* чиним тест (реализованные методы)
* проводим рефакторинг, если необходим (новый абстракции, декомпозиция, извлечение методов)
* создать класс
* напсиать новый тест

**TFD**
Все уже спроектировано на бумаге(в голове). Поведение нужно просто реализовать

**TDD порождает достаточный проект**
**TDD порождает любой проект, который возникает в голове разработчика**

### Добавочное тестирование
**Пирамида тестирования**
                      /\  РУЧНОЕ
                    /    \
                  / ______ \
                / ПРИЕМОЧНЫЕ \ автотесты, повторение действий пользователей (на стенде) 
              /  _________     \
            /   ИНТЕГРАЦИОННЫЕ   \ тесты API интерфейса, где служба, как черный ящик
          / _________________      \
        /          МОДУЛЬНЫЕ         \
        --------------------------  
Каждый уровень пирамидыуказывает, что один ярус должен быть меньше другого

**Антипаттерны**
* песочные часы МОДУЛЬНЫЕ - интеграционные(мало) - ПРИЕМОЧНЫЕ
* рожок модульные - интеграционные - ПРИЕМОЧНЫЕ - признак спутанного нетестируемого кода, поэтому покрыты внешними

### Тестирование для профилактики проблем
Доверие - в нем ценность тестов
Неудача - лучший учитель
Нужно сместить внимание со средней наработки на отказ (Mein Tain Before failure)  в сторону среднего времени восстановлениея (Mein Time ToRecovery). MTTR - не только допускает отказ, но и допускает его























