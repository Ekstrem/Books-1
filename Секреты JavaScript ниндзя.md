**DOM** - объектная модель документа. Структурированное преставление пользовательского интерфейса клиентского приложения, которое перваначально строится на коде HTML
**События**
**Api браузера** - взаимодействие с внешним миром через интерфейс, который позволяет получать информацию об устройствах, сохранять данные локально

Анализ производительности через console.time() -> console.timeEnd()
Войны браузеров закончились, когда были стандартизированы HTML, CSS, интерфейс DOM API и JS

**Создание страницы в динамическом режиме**
Браузер - интерпретатор, выполняющий код JS

**Жизненный цикл веб-приложения**
1. Вводится урл
2. Браузер составляет запрос и отправляет серверу
3. Сервер обрабатывает запрос и составляет ответ из HTML разметки + CSS + JS
4. При получении ответа от севера начинается жизненный цикл приложения

Клиентские веб-приложения - это приложения с графическим пользовательским интерфейсом, поэтому выполняются стадии
1. Создание страницы
2. Обработка собития => вход в цикл ожидания событий и их выполнение при наступлении события

**Создание страницы**
* синтаксический анализ HTML-разметки и построение DOM(объектной модели)
* выполнение кода JS

**Синтаксический анализ**
* на основе входящего HTML строится дерево DOM, каждый элемент разметки
* узел дерева. HTML и DOM не одно и тоже. HTML - это как бы схема, по котрой браузер строит первоначальную модель DOM

Если направильно сделать HTML, то иногда браузер исправляет сам. Например убирает лишние теги в <head/>
**Сейчас действует HTML5 и DOM3**

**Выполнение кода JS**
Весь код находтся в script, он выполняется встроенным в браузер интепретатором(Spidermonkey B 6pay3epe Firefox, VS -B 6payepax Chrome 11 Opera HJIH Chakra -B  6paY3epe Microsoft  Edge)
Js нужен для динамичности страницы, браузер предоставляет интерфейс API через глобальный объект, который используется интерпретатором JS для взаимодействия и изменения страницы

**Глобальные объекты в JS**
Для JS бразузер делает доступным window - исходный глобальный объект, через него достпные свойства, api-браузера
Например, window.document - DOM текущей страницы, через него возможно манипулировать DOM

**Разные типы кода JS**
* глобальный код
* код функции - код, содержащийся в теле функции

Код за пределами функций - глобыльный код

**Выполенение кода JS на этапе создания страницы**
Когда браузер достигает узла script, то приостанавливает построение модели на основании DOM и приступает к выполнению script. Выполняется глобальный код и из глобального кода вызываются функции

Нельзя изменять(манипулировать) несуществующими узлами DOM из script - если элемент создается после script, на время выполнения скрипта состояние и глобальные переменные сохраняются в window

**Обработка событий**
Среда выполенения браузера действует по принципу поочередного выполнения фрагментов в соответствии с моделью однопоточного выполнения. Чтобы не терять произведенные события в браузере организуется очередь событий.

**Все события от пользователя или сервера(ajax) ставятся в очередь в том порядке, в котором обнаруживается браузер**

**Процесс обработки событий**
* браузер отслеживает содержимое  начала очереди события
* если нет событий браузер ожидает
* если в начале очереди есть события, браузер извлекает из очереди, запускает необходимый обработчик, остальные события ждут

**Работа с очередью происходит в другом потоке**. При этом создается ощущение ассинхронности, т.к не блокируется интерфейс

**Регистрация обработчиков**
addEventListener - несколько функций
window.onload - только одна функция для обработки конкретного события, а значит можно случайно перезаписать предыдущие функции обработки событий
После обработки события оно удаляется из очереди
В один момент врменеи может быть выполнен только один обработчик из-за однопоточного

## Представление о функциях
**Функции высшего порядка**
* функции - это объекты высшего порядка и основной модульный исполняемый блок.
* функции создаются с помощью литералов {}, добавляются в массив. Все что можно делать с объектами, можно делать с функциями
* функция обратного вызова - это когда функции можно передавать в качестве аргумента другую функцию
* функции можно создавать везде, где может понадобиться выражение в коде.

**Особенности применения функций как объектов**
**Сохранение функции в коллекции**
Если, например, появляется задача манипулирования набором функций при настраивании события, может потребоваться коллеция функций. 
Как идентифицировать функцию, чтобы не создать дубликатов? Можно создать объект(массив) с функциями и перед добавлнием в массив проверять есть ли у функции индентификатор, т.е ввести для функции идентификатор fn.id и заполнять его при добавлении в коллекцию

**Запоминание функций**
Это процесс построения функций, способной запоминать свои вычисленные значения.
Переменная является свойством самой функции и действует до тех пор, пока действует сама функция

**Опредление функций**
* function функциональное выражение
* => стрелочные функции
* через конструктор Function() для динамического конструирования функции
* функции-генераторы function* myGen() - функции, из которых можно выйти и снова зайти при существовании продолжения

**Функции и функциональные выражения**
```
function [name]([param1], [param2])
```
Функции могут определяться как отдельный оператор, так и внутри оператора

**Функциональные выражения**
```
var a = function();
myFunction(function(){} // выражения фактически делают ссылку на функцию без фактического выполнения)
```
В функциональном выражении не обязательно имя
Если требуется вызвать функцию, то с этой целью используется выражение, интерпретируемое, как функция с последующей парой ()

**Немедленно вызываемые функции**
```
(function(){}()
```
круглые скобки указывают синтаксическому анализатору, что это выражение, если бы не было - была бы ошибка, так как в объявлении функции обязательно имя. Можно использовать + или - или ! перед function

**Стрелочные функции**
По сути синтаксический сахар
```
var value = name => "Ivan" + name
```
В сложных функциях обязателен return.

**Аргументы и параметры функций**
Аргумент - то что определено в функции
Параметр - то что передается

Если число аргументов отличается от числа парметров, то лишние аргуемнты не присваиваются именам параметров. Если аргементов, то присваивается undefined

**Оставшиеся параметры (rest)**
```
function multyMix ( first, ...remainingNumbers){
    remainingNumbers.manipulate()
}
```
remainingNumbers превращаются в массив осташихся параметров.
Вызвать функцию можем как ```multyMix(1, 2, 3, 4) ```
Всегда на последнем месте объявления

**Стандартные параметры**
```function(ninjam action="jump")```
Стандарный параметр может быть любым. Но лучше не переусердствовать со сложностью

**Неявные параметры**
В функцию, помимо явно указываемых параметров в определении функции, при ее вызове явно передаются неявные параметры ``arguments``и ``this``
``Arguments`` - коллекция всех аргументов, передаваемых функции. ``lenfth`` - количество аргументов. Arguments  - это параметры не объявленные, но переданные в функцию, как аргументы.
```
function read(a, b, c){}
read(1, 2, 3, 4, 5) // можно обратиться через arguments[4], arguments[5]
```
**arguments не массив, просто похож**
На текущий момент не нужен, т.к есть rest
* если изменить значение arguments[i] = k, то именованный параметр поменяет знаечние. обратное тоже действует. Значит у аргумента есть псевдоним
* для отключения такого поведения используем ``use strict`` и тогда, arguments[i] = r не изменит знаечние параметра.

**Параметр this**
* this - это объект связынный с вызовом функции - контекст функции.
* this опеределяется не тем, как функция объявляется, а тем, как вызывается






















