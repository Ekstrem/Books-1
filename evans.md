# Эрик Эванс
# Модель предметной области в работе
## Переработка знаний
Любая система - это цепочка этапов с разветвлениями как условиями или вершинами выбора
### Составление эффективного моделирования
* установка связи межжу моделью и релизацией (Связь с действительностью)
* ввод языка, основанного на модели (Общий понятийный аппарат)
* разработка информоемкая модели (Содержание общией информации разного рода)
* дистиляция модели (Отброс второстепенных понятий либо вон, либо в новую модель)
* мозговые штурмы (Event Storming)

**Переработка знаний**- важный элемент дейтельности программиста. Обработать много информации и сформировать ее в видимую модель. Все это вместе с командой (специалистов предметной области, пользователей систем, технической поддержки).

Плохой стиль переботки - каскадный: специалист -> аналитик -> программист. Знания перетекают в одном направлении и не накапливаются.
Плохой стиль "итерационный": если от специалистов приходят таски по очереди и программисты не пытают абстрагироваться

#### Постоянное обучение
Любая предметная область может приподносить сюрпризы и нельзя ее недооценивать
**NB невежество заставляет делать неверные предположения**
Вся команда должна непрерывно обучаться

#### Информоемкая архитектура
Прояснение через переработку знаний: самых скрытых знаний (правил). Донести важность таких незначительных правил специалистам

#### Углубленные модели
ПОнять что именно необходимо автоматизировать. Первоначальная постановка может быть далека от того, что нужно

## Коммуникация и язык
Модель предметной области может служить основой общего языка для коммуникации в рамках проекта по разработке ПО
**NB Модель - это набор понятий с названиями, терминами, отношениями, взаимосвязями, отражающими понимание предметной области**

**NB Термины и связи - это семантика языка, адаптированная к предметной области**
Язык нужен для разработки информоемкой архитектуры программыю  Отсутствие языка порождает(ухудшает) обмен знаниями не только между специалистами, но и между членами разных команд. Не должно быть перевода между членами.

### Словарь единого языка
* имена классов и основных операций(глаголов)
* термины для обсуждения правил
* термины из принципов высокоуровневой реализации (карта контекстов, крупномасштабная архитектура)
* названия шаблонов

Изменения в языке - это изменения в модели и нужно переименовывать понятия, методы в угоду появившемуся новому знанию
* Нужно старать пользоваться языком, если он неудобен, то это повод пересмотреть термины
* Единый язык должен находить отражение везде: модель (от нее изначально оттталкиваемся), документация, схемы разговор

**Единый язык** - основной носитель тех аспектов, архтектуры, которые не проявляются в коде; крупномасштабной структуре; организающих всю систему, ограниченных контекстов, опредлеляющих отношение между разными системами и моделями, например, шаблонов, относящихся к модели и программной архитектуре

Единый язык сложно внедрять. Может помочь обсуждение вслух: Через дискуссию программисты и специалисты могут найти неточности в ходе своего мышления и, если неточность найдена, ее можно и нужно прояснить.

Единый язык  - это смесь жаргона специалистов, программистов, терминов предметной области. И, как следствие, это потенциальные термины модели, имена ограниченных контекстов и терминология крупномасштабной структуры

### Диаграммы, схемы, диаграммы
* Схемы нужны для более простого взаимодействия (наглядного). Не стоит все переносить на них.
    * Можно нарисовать схему с текстом, определить классы и функции словами
    * Схема может быть от руки, лишь бы была читаема
* Документация характеристики
    * Должна дополнять код и устные обсуждения
    * Код не может быть документацией: слишком сух, а иногда и абстракте(или слишком конкретен)
    * В ней не может быть деталей реализации, это обязанность кода
    * Должна отразить смысл, помочь понять крупномасштабную архитектуру
    * Должна сконцентрировать внимание на ключевых элементах
    * Не должна отставать от процесса
    * Должна меняться и должна быть гибкой(без лишних инструкций и уточнений)

Документация должна:
* разъяснить понятийный аппарат модели
* помогать ориентироваться в деталях кода
* дать понимание, как должна использоваться модель
* должна быть написана на едином языке
* должна помочь в написании ТЗ, пользовательской документации

**Если документация не влияет на единый язык, т.е ее не заполняют, не используют, то она либо составлена неверно (слишком много - слишком мало), либо не отражает реальной стадии разработки**

### Пояснительная модель
Модель, по которой выполняется проектирование - это один взгляд на проблему, но для обучения, ввода в курс дела полезно иметь вспомогательные точки зрения для лучшей передачи общих данных
Можно предствить предметную область, как пояснительную модель. Пояснительную модель можно расширять схемой или документацией. Например, есть модель в системе терминов, но для непосвященных это может лишь запутать ситуацию и тут-то является пояснительная модель (схема, график) для более наглядного представления. А модель  - это список связей с блоками, отражающая архитектуру приложения, в виде более строгихдиаграмм, таблиц, схем. 
**Важно четко понимать разницу между пояснительной моделью и рабочую модель**

# Связь между моделью и реализацией
Иногда сформуированная модель может быть очень детальной и подробной, но при попытке ее реализовать оказывается множество связей и связности. Т.е она не влияет на разработку разработку
**Модель в DDD  - прочный фундамент для архитектуры приложения**

## Проектирование по модели
Аналитическая модель - результат ананлиза прикладной темы, ее систематизация без учета роли, которую она будет играть в программной системе. Программная архитектура строится опосредовано по аналитической модели, лишь ссылаясь как на "логику" поведения. Но фактически модель не всегда помогает понять предметную область, напротив, запутывая ее.
**Иногда из-за наличия аналитиков разработчики не имеют возможности принять участие в анализе**

## Этапы проектирования и анализа
* Извлечь фундаментальные понятия и представить их (анализ)
* Задать набор компонентов, которые конструируются с помощью средств разработкидля решения поставленной задачи (проектирование)
* поиск модели между анализом и архитектурой (MDD - model driver design)
Как следствие получаем единый процесс моделирования и проектирвоания.

Модель должна использовать единый язык. Модель будет совершенствоваться итерационно. Вокруг нее будет строиться проектирование

## Парадигмы моделирования и средства программирования
* Процедурная
* Логическая
* ООП

Каждая из них выполняет свою задачу. И исходя из ориектирования вокруг модели можно выбрать, например, ООП или функциональную парадигму. Архитектура тянет парадигму.

## Анатомия модели
Проектирование модели требует работы только с одной моделью. Никаних дополнительных, избыточных или усеченных модулей. Все строится вокруг полной модели

## Моделировщики практики
Высококвалифицированные конструируют и моделируюит, остальные реализуют. 
НО DDD требует проектирования от всех. 
* Если одни проектируют, а другие пишут код, то теряется владение знанием, получается испорченный телефон. Программисты не чувствуют ответственности за модели и не понимают ее необходимости. Не будут понимать, что изменение кода ведет к изменению модели, тогда их рефакторинг будет вредить.
* Проектировщик будет терять связь с миром технологий, пониание требований и собенности реализации. В обсуждении рождается истина. Даже если выделены проектироващики, они должны тесно взаимодействавать и обсуждать концепции с разработчиками

# Изоляция предметной области
## Многоуровневая архитектура
Необходимо ограничить объекты предметной области от общих функций системы и избежать путаницы между понятиями предметной области и остальных функций системы.

Уровни: 
* **Интерфейс пользователя**вывод информации пользователю, интерпретирование его команд. Внешним субъектом может быть не только человек, но и информационная система. 
* **Операционный** - распрделение работы между совокупностями на более низкие уровни. В нем нет отражения состояния, объектов, предметов прикладной модели, но может быть состояние, для информирования ользователя о степени выполнения задачи
* **Предметной области** прелставляет понятие прикладной предметной области, рабочие состояния, деловые регламенты. Здесь используется текущее состояние прикладной модели, этот уровень главная алгоритмическая часть
* **Инфраструктурный** - техническая поддержка верхних уровней, берет на себя поддержку схему взаимосвязей между всеми уровнями. 
**Когда код размазал по базе фронту его сложнее анализировать, изменять и искать. Получается каждое изменение влечет непредсказуемое поведение в лругих слоях.**

Основной принцип многоуровневой архитектуры - каждый уровень зависит от работы элеиентов этого кровня и от более низких уровней. **Ценность многоуровневости** - это специализация каждого уровня на конкретном аспекте программы. Уровней может быть больше, но все они должны следовать главному правилу.

Разные уровни можно разместить на разных серверах.
**Необходимость операционного уровня: при измении испочника запроса - точка всегда юудет единой, помогает поддерживать архитектуру в целостном виде**

### Связь между уровнями
* Уровни должны быть связаны нежестко и сверху-вниз
* верхние уровни манипулируют нижними через вызов публичных методов, хранения ссылок на них
* если нужна связь снизу вверх, то нужно реализовывать сообщениями или паттерном наблюдатель
* инфраструктурный уровень не инициирует операций на уровне предметной области
* техничесике возможности(инфраструктурный уровень) предоставляются в виде служб, например, посласть письмо: оперативный уровень запрашивает передачу сообщения - это дополнительная помощь для операционного уровня, но при этом он не знает технической сложности службы
* некоторые технические компоненты проектируются так, чтобы напрямую поддерживать функционирование других уровней(абстрактный базовый класс)

### Архитектурные среды
Речь идет об инфраструктурном уровне, где не все решается использованием интерфейсов. Среды, которые могут влиять на предметный уровень. Например решение реализовать модель в виде объектов конкретной ORM. Важно не выбирать жестко готовое решение раз и навсегда, а делать выбор в пользу полезности для работы над предметной моделью

## Уровень предметной области- вместилище модели
**Для DDD ключевой областью(слоем) является предметной слой, уровень предметной области**
Модель предметной области(**domain model**) - это набор понятий. Уровень предметной области (layer) - выражение данной модели и всех элементов программной архитектуры, имеющие к ней отношение. Этот уровень образуется путем проектирования и реализации всей совокупности понятий и связей в предметной области. Такого рода проектирование, конструкции уровня предметной области отражают концепции модели.
**Изрляция предметной области - это основа DDD**

## Антипаттерн интеллектуального интерфейса пользователя
Реализация логики внутри интерфейса пользователя. Хранение - общая реляционная БД. Плюсы и минусы очевидны.

# Модель, выраженная в программе
Связь между моделью и реализацией необходимо проектировать на уровне деталей.

**Основное различие сущности  и объекта-значения в том, что сущность имеет протяженность и обособленность, а объект-значение  выражает состояние предметной области.**

Служба(Services)  - это что-то срабатывающее на запрос клиента. На уровне предметной области они появляются при моделировании деятельности, которая соответствует опрерациям программы, но не ассоциируется ни с каким ее состоянием.

## Ассоциации
При необходимости соблюсти однозначное соответствие между моделью и программной реализацией сложнее всего при создании ассоциаций между объектами
Для всякой прослеживаемой в модели ассоциации должен существовать механизм в программе, обладающий теми же свойствами (связь между покупателем и продавцом в магазине, связь в коде между объектами). **Реализация может быть разной, но должна быть в архитекутре предусмотрена**

### Правила упрощения ассациаций
1. Свести отношения к однонаправленным (снижает связность и упрощает структуризацию)
    * Отпределить, какое соотношение важнее (отель в какой стране? - какие отели в стране?)
    * Можно последовательно пытаться ограничить ассоциации и , как следствие, упростить и сделать значимыми оставшиеся ассоциации
2. Добавить квалификаторы
    * путин - президент? президент какой страны путин? - класс человек независим от менее функдаментального президент.
        Выбор главного направления из "многие ко многим" сужает его к "один к одному"
3. устранить несущественные ассоциации

## Сущности
Многие объекты не сводятся к набору атрибутов, а характеризуются непрерывностью и индивидуальностью существования. Индентичность - это то, что определяет именно его. (Как определить, что сущность(человек) именно тот, кем является?)
Десять лет назад для понимания сущности главное не атрибуты, а абстрактное непрерывное существование в течение всего жизненного цикла, даже с переходом в разные формы

Для некоторых объектов опредление через атрибуты не главное. Они непрерывно существуют во времени, переходят в состояния, но не утрачивают своего значения (понимания-смысла). Может существовать две сущности с одинаковыми атрибутами, но разными по факту.
* Эти обекты должны идентифицироваться таким образом, чтобы их можно было однозначно опредить.
* Определение классов обязанностей, атрибутов, ассоциаций для них следует строить вокруг смыслового значения, а не атрибутов (человек, город, авто, билет и т.д)

**Индивидуальное существование  - это тонкий смысловой атрибут, который невсегда возможно превратить в стандартное средство единого языка**

**Иногда имеет смысл посмотреть на транзакцию, как на сущность**

### Правила
* если объект определяется индивидуальным существованием, а не набором атрибутов, это свойство следует следует считать главным в определении объекта в модели
* класс должен строиться вокруг непрерывности и уникальности цикла объекта
* найти способ разлисать объект вне зависимости от формы и существования
* обратить внимание к техническими требованиям, необходимым для сопоставления объектов по атрибутам
* создать операцию, которая способна генерировать новый результат для объекта(например, GUID). Она(операция) должна соответствовать правилам различения объектов в модели.
* должно даваться точно определение, что такое разные объекты
* если у объекта нет уникального признака (место без номера), то, возможно, это не сущность

## Моделировани сущностей
При моделировании объекта нужно думать об атрибутах и важно думать о его поведении, рабочих функциях.
Основная функция сущности - поддерживать непрерывность существования, чтобы поведение было понятным и предсказуемым. как следствие выведем правила:
1. ограничиваем определение сущности неотъемлемыми характеристиками (то что используется для поиска и сравнения)
2. задаем только те функции, которые существенны для создания понятия об объекте 
3. задать атрибуты, которые требуют функции (2)
4. остальные атрибуты и функции и объекты выносим в другие функции или объекты-знаечния

**Функции координируют операции объектов, которые им принадлежат. Номер телефона не может быть уникальным, но можно вынести в деловые контакты**

## Проектирование операций идектификации
* может быть некоторый уникальный признак
* если нет - присваиваем уникальный код сами (в рамка плана уникальный)
* могут быть разные способы генерации (важно помнить о том, что система может быть рапределеннной)
* идентификатор может быть внутренним (не нужно показыать пользователям). Могут быть необходимы для пользователя (коды подтверждения для токенов в письмах)
* если нужен общий для разных организаци (например использование федерального или общепринятого справочника)
* иногда можно ожидать определения индивидуальных идентификаторов от пользователя (логин - почта)






















































