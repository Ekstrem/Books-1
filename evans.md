# Эрик Эванс
# Модель предметной области в работе
## Переработка знаний
Любая система - это цепочка этапов с разветвлениями как условиями или вершинами выбора
### Составление эффективного моделирования
* установка связи между моделью и реализацией (Связь с действительностью)
* ввод языка, основанного на модели (Общий понятийный аппарат)
* разработка информоемкая модели (Содержание общей информации разного рода)
* дистилляция модели (Отброс второстепенных понятий либо вон, либо в новую модель)
* мозговые штурмы (Event Storming)

**Переработка знаний**- важный элемент деятельности программиста. Обработать много информации и сформировать ее в видимую модель. Все это вместе с командой (специалистов предметной области, пользователей систем, технической поддержки).

Плохой стиль переработки - каскадный: специалист -> аналитик -> программист. Знания перетекают в одном направлении и не накапливаются.
Плохой стиль "итерационный": если от специалистов приходят таски по очереди и программисты не пытают абстрагироваться

#### Постоянное обучение
Любая предметная область может преподносить сюрпризы и нельзя ее недооценивать
**NB невежество заставляет делать неверные предположения**
Вся команда должна непрерывно обучаться

#### Информоемкая архитектура
Прояснение через переработку знаний: самых скрытых знаний (правил). Донести важность таких незначительных правил специалистам

#### Углубленные модели
Понять, что именно необходимо автоматизировать. Первоначальная постановка может быть далека от того, что нужно

## Коммуникация и язык
Модель предметной области может служить основой общего языка для коммуникации в рамках проекта по разработке ПО
**NB Модель - это набор понятий с названиями, терминами, отношениями, взаимосвязями, отражающими понимание предметной области**

**NB Термины и связи - это семантика языка, адаптированная к предметной области**
Язык нужен для разработки информоемкой архитектуры программы.  Отсутствие языка порождает(ухудшает) обмен знаниями не только между специалистами, но и между членами разных команд. Не должно быть перевода между членами.

### Словарь единого языка
* имена классов и основных операций(глаголов)
* термины для обсуждения правил
* термины из принципов высокоуровневой реализации (карта контекстов, крупномасштабная архитектура)
* названия шаблонов

Изменения в языке - это изменения в модели и нужно переименовывать понятия, методы в угоду появившемуся новому знанию
* Нужно стараться пользоваться языком, если он неудобен, то это повод пересмотреть термины
* Единый язык должен находить отражение везде: модель (от нее изначально отталкиваемся), документация, схемы разговор

**Единый язык** - основной носитель тех аспектов, архитектуры, которые не проявляются в коде; крупномасштабной структуре; организующих всю систему, ограниченных контекстов, определяющих отношение между разными системами и моделями, например, шаблонов, относящихся к модели и программной архитектуре

Единый язык сложно внедрять. Может помочь обсуждение вслух: Через дискуссию программисты и специалисты могут найти неточности в ходе своего мышления и, если неточность найдена, ее можно и нужно прояснить.

Единый язык  - это смесь жаргона специалистов, программистов, терминов предметной области. И, как следствие, это потенциальные термины модели, имена ограниченных контекстов и терминология крупномасштабной структуры

### Диаграммы, схемы, диаграммы
* Схемы нужны для более простого взаимодействия (наглядного). Не стоит все переносить на них.
    * можно нарисовать схему с текстом, определить классы и функции словами
    * схема может быть от руки, лишь бы была читаема
* Документация характеристики
    * должна дополнять код и устные обсуждения
    * код не может быть документацией: слишком сух, а иногда и абстракте(или слишком конкретен)
    * в ней не может быть деталей реализации, это обязанность кода
    * должна отразить смысл, помочь понять крупномасштабную архитектуру
    * должна сконцентрировать внимание на ключевых элементах
    * не должна отставать от процесса
    * должна меняться и должна быть гибкой(без лишних инструкций и уточнений)

Документация должна:
* разъяснить понятийный аппарат модели
* помогать ориентироваться в деталях кода
* дать понимание, как должна использоваться модель
* должна быть написана на едином языке
* должна помочь в написании ТЗ, пользовательской документации

**Если документация не влияет на единый язык, т.е ее не заполняют, не используют, то она либо составлена неверно (слишком много - слишком мало), либо не отражает реальной стадии разработки**

### Пояснительная модель
Модель, по которой выполняется проектирование - это один взгляд на проблему, но для обучения, ввода в курс дела полезно иметь вспомогательные точки зрения для лучшей передачи общих данных
Можно представить предметную область, как пояснительную модель. Пояснительную модель можно расширять схемой или документацией. Например, есть модель в системе терминов, но для непосвященных это может лишь запутать ситуацию и тут-то является пояснительная модель (схема, график) для более наглядного представления. А модель  - это список связей с блоками, отражающая архитектуру приложения, в виде более строгих диаграмм, таблиц, схем. 
**Важно четко понимать разницу между пояснительной моделью и рабочую модель**

# Связь между моделью и реализацией
Иногда сформулированная модель может быть очень детальной и подробной, но при попытке ее реализовать оказывается множество связей и связности. Т.е она не влияет на разработку разработку
**Модель в DDD  - прочный фундамент для архитектуры приложения**

## Проектирование по модели
Аналитическая модель - результат анализа прикладной темы, ее систематизация без учета роли, которую она будет играть в программной системе. Программная архитектура строится опосредовано по аналитической модели, лишь ссылаясь как на "логику" поведения. Но фактически модель не всегда помогает понять предметную область, напротив, запутывая ее.
**Иногда из-за наличия аналитиков разработчики не имеют возможности принять участие в анализе**

## Этапы проектирования и анализа
* извлечь фундаментальные понятия и представить их (анализ)
* задать набор компонентов, которые конструируются с помощью средств разработки для решения поставленной задачи (проектирование)
* поиск модели между анализом и архитектурой (MDD - model driver design)
Как следствие получаем единый процесс моделирования и проектирования.

Модель должна использовать единый язык. Модель будет совершенствоваться итерационно. Вокруг нее будет строиться проектирование

## Парадигмы моделирования и средства программирования
* процедурная
* логическая
* ООП

Каждая из них выполняет свою задачу. И исходя из ориентирования вокруг модели можно выбрать, например, ООП или функциональную парадигму. Архитектура тянет парадигму.

## Анатомия модели
Проектирование модели требует работы только с одной моделью. Никаних дополнительных, избыточных или усеченных модулей. Все строится вокруг полной модели

## Моделировщики практики
Высококвалифицированные конструируют и моделируют, остальные реализуют. 
НО DDD требует проектирования от всех. 
* если одни проектируют, а другие пишут код, то теряется владение знанием, получается испорченный телефон. Программисты не чувствуют ответственности за модели и не понимают ее необходимости. Не будут понимать, что изменение кода ведет к изменению модели, тогда их рефакторинг будет вредить.
* проектировщик будет терять связь с миром технологий, понимание требований и особенности реализации. В обсуждении рождается истина. Даже если выделены проектироващики, они должны тесно взаимодействовать и обсуждать концепции с разработчиками

# Изоляция предметной области
## Многоуровневая архитектура
Необходимо ограничить объекты предметной области от общих функций системы и избежать путаницы между понятиями предметной области и остальных функций системы.

Уровни: 
* **Интерфейс пользователя**вывод информации пользователю, интерпретирование его команд. Внешним субъектом может быть не только человек, но и информационная система. 
* **Операционный** - распределение работы между совокупностями на более низкие уровни. В нем нет отражения состояния, объектов, предметов прикладной модели, но может быть состояние, для информирования пользователя о степени выполнения задачи
* **Предметной области** представляет понятие прикладной предметной области, рабочие состояния, деловые регламенты. Здесь используется текущее состояние прикладной модели, этот уровень главная алгоритмическая часть
* **Инфраструктурный** - техническая поддержка верхних уровней, берет на себя поддержку схему взаимосвязей между всеми уровнями. 
**Когда код размазал по базе фронту его сложнее анализировать, изменять и искать. Получается каждое изменение влечет непредсказуемое поведение в лругих слоях.**

Основной принцип многоуровневой архитектуры - каждый уровень зависит от работы элементов этого уровня и от более низких уровней. **Ценность многоуровневости** - это специализация каждого уровня на конкретном аспекте программы. Уровней может быть больше, но все они должны следовать главному правилу.

Разные уровни можно разместить на разных серверах.
**Необходимость операционного уровня: при изменении источника запроса - точка всегда будет единой, помогает поддерживать архитектуру в целостном виде**

### Связь между уровнями
* уровни должны быть связаны не жестко и сверху-вниз
* верхние уровни манипулируют нижними через вызов публичных методов, хранения ссылок на них
* если нужна связь снизу вверх, то нужно реализовывать сообщениями или паттерном наблюдатель
* инфраструктурный уровень не инициирует операций на уровне предметной области
* технические возможности(инфраструктурный уровень) предоставляются в виде служб, например, послать письмо: оперативный уровень запрашивает передачу сообщения - это дополнительная помощь для операционного уровня, но при этом он не знает технической сложности службы
* некоторые технические компоненты проектируются так, чтобы напрямую поддерживать функционирование других уровней(абстрактный базовый класс)

### Архитектурные среды
Речь идет об инфраструктурном уровне, где не все решается использованием интерфейсов. Среды, которые могут влиять на предметный уровень. Например решение реализовать модель в виде объектов конкретной ORM. Важно не выбирать жестко готовое решение раз и навсегда, а делать выбор в пользу полезности для работы над предметной моделью

## Уровень предметной области- вместилище модели
**Для DDD ключевой областью(слоем) является предметной слой, уровень предметной области**
Модель предметной области(**domain model**) - это набор понятий. Уровень предметной области (layer) - выражение данной модели и всех элементов программной архитектуры, имеющие к ней отношение. Этот уровень образуется путем проектирования и реализации всей совокупности понятий и связей в предметной области. Такого рода проектирование, конструкции уровня предметной области отражают концепции модели.
**Изоляция предметной области - это основа DDD**

## Антипаттерн интеллектуального интерфейса пользователя
Реализация логики внутри интерфейса пользователя. Хранение - общая реляционная БД. Плюсы и минусы очевидны.

# Модель, выраженная в программе
Связь между моделью и реализацией необходимо проектировать на уровне деталей.

**Основное различие сущности  и объекта-значения в том, что сущность имеет протяженность и обособленность, а объект-значение  выражает состояние предметной области.**

Служба(Services)  - это что-то срабатывающее на запрос клиента. На уровне предметной области они появляются при моделировании деятельности, которая соответствует операциям программы, но не ассоциируется ни с каким ее состоянием.

## Ассоциации
При необходимости соблюсти однозначное соответствие между моделью и программной реализацией сложнее всего при создании ассоциаций между объектами
Для всякой прослеживаемой в модели ассоциации должен существовать механизм в программе, обладающий теми же свойствами (связь между покупателем и продавцом в магазине, связь в коде между объектами). **Реализация может быть разной, но должна быть в архитектуре предусмотрена**

### Правила упрощения ассоциаций
1. свести отношения к однонаправленным (снижает связность и упрощает структуризацию)
    * определить, какое соотношение важнее (отель в какой стране? - какие отели в стране?)
    * можно последовательно пытаться ограничить ассоциации и , как следствие, упростить и сделать значимыми оставшиеся ассоциации
2. добавить квалификаторы
    * Путин - президент? президент какой страны Путин? - класс человек независим от менее фундаментального президент.
        выбор главного направления из "многие ко многим" сужает его к "один к одному"
3. устранить несущественные ассоциации

## Сущности
Многие объекты не сводятся к набору атрибутов, а характеризуются непрерывностью и индивидуальностью существования. Индентичность - это то, что определяет именно его. (Как определить, что сущность(человек) именно тот, кем является?)
Десять лет назад для понимания сущности главное не атрибуты, а абстрактное непрерывное существование в течение всего жизненного цикла, даже с переходом в разные формы

Для некоторых объектов определение через атрибуты не главное. Они непрерывно существуют во времени, переходят в состояния, но не утрачивают своего значения (понимания-смысла). Может существовать две сущности с одинаковыми атрибутами, но разными по факту.
* эти объекты должны идентифицироваться таким образом, чтобы их можно было однозначно опередить.
* определение классов обязанностей, атрибутов, ассоциаций для них следует строить вокруг смыслового значения, а не атрибутов (человек, город, авто, билет и т.д)

**Индивидуальное существование  - это тонкий смысловой атрибут, который не всегда возможно превратить в стандартное средство единого языка**

**Иногда имеет смысл посмотреть на транзакцию, как на сущность**

### Правила
* если объект определяется индивидуальным существованием, а не набором атрибутов, это свойство следует следует считать главным в определении объекта в модели
* класс должен строиться вокруг непрерывности и уникальности цикла объекта
* найти способ различать объект вне зависимости от формы и существования
* обратить внимание к техническими требованиям, необходимым для сопоставления объектов по атрибутам
* создать операцию, которая способна генерировать новый результат для объекта(например, GUID). Она(операция) должна соответствовать правилам различения объектов в модели.
* должно даваться точно определение, что такое разные объекты
* если у объекта нет уникального признака (место без номера), то, возможно, это не сущность

## Моделирование сущностей
При моделировании объекта нужно думать об атрибутах и важно думать о его поведении, рабочих функциях.
Основная функция сущности - поддерживать непрерывность существования, чтобы поведение было понятным и предсказуемым. как следствие выведем правила:
1. ограничиваем определение сущности неотъемлемыми характеристиками (то что используется для поиска и сравнения)
2. задаем только те функции, которые существенны для создания понятия об объекте 
3. задать атрибуты, которые требуют функции (2)
4. остальные атрибуты и функции и объекты выносим в другие функции или объекты-значения

**Функции координируют операции объектов, которые им принадлежат. Номер телефона не может быть уникальным, но можно вынести в деловые контакты**

## Проектирование операций идентификации
* может быть некоторый уникальный признак
* если нет - присваиваем уникальный код сами (в рамка плана уникальный)
* могут быть разные способы генерации (важно помнить о том, что система может быть распределенной)
* идентификатор может быть внутренним (не нужно показать пользователям). Могут быть необходимы для пользователя (коды подтверждения для токенов в письмах)
* если нужен общий для разных организации (например использование федерального или общепринятого справочника)
* иногда можно ожидать определения индивидуальных идентификаторов от пользователя (логин - почта)

##  Объекты-значения
Объекты без индивидуального существования описывают характеристики того или иного объекта

**Пример** Рисунок - сущность, чем его рисовали и в какой технике - характеристики

**Один и тот же объект в разных ситуациях может быть сущностью или объектом-значением.** Адреса для человека - это объект-значение, а для ФИАС  - сущность

Объект-значение  - это объект, представляющий описанный аспект предметной области и не имеет индивидуального существования, собственной идентичности
* объект-значение может представлять совокупность других объектов
* может ссылаться на сущности (нужный маршрут состоит из сущностей населенный пункт, дорога)
* может пересылаться в сообщениях между объектами
* может носит временный характер
* может использоваться как атрибут сущности (человек - сущность, объект-значение - имя)
**если элемент модели определяется своими атрибутами(полностью), то это объект-значение**
* сделайте, чтобы объект-значение отражал смысл заложенных в него атрибутов атрибутов, придайте соответствующую функциональность
* нужно считать его неизменяемым
* не должен содержать индивидуальности
* должен быть целостным (не три значения улица, город, страна), а одно - адрес

### Проектирование объектов-значений
Есть одно имя у двух человек. Один имя поменял. Менять значение объекта нельзя, так как изменится имя другого человека 
Можно сделать вывод:
* объект-значения не изменяем, а заменяем
* может быть многократно используем для разных сущностей (с сущностью такое не пройдет)

#### Случаи изменяемости
* частое изменение
* затраты создание-уничтожения
* опасность замены при группировании (совместное использование)
  если объект-значение изменяем, то он не должен использоваться совместно

**Чтобы иметь возможность технически оптимизировать быстродействие, необходимо избегать связей и ограничений в модели**

**!! В реляционной БД можно провести денормализацию с целью засунуть объект-значение из отдельной таблицы в таблицу-сущности. Для экономии времени**

**В распределенной  системе, если хранить ссылку на объект-значение на другом сервере, может замедлиться передача сообщений, поэтому лучше передавать на другой сервер копию объекта**

Нужно избегать двунаправленной ассоциации между объектами-значениями

## Службы
* служба не инкапсулирует состояние 
* большинство служб находятся на инфраструктурном уровне и имеют технический характер
* службы на уровне предметной области взаимодействуют с инфраструктурными (при изменении баланса  - отсылаем письмо)
* отличить службы операционного уровня и предметной области: операционный уровень отдаем команду на перевод денег, а реализация перевода денег - фундаментальная операция предметной области **Грань тонка**
* в службах предметной области реализуются деловые регламенты

### Распределение служб по уровням
#### Операционный
* принимает входные данные
* посылает сообщение в службу модели для выполнения
* ожидает подтверждения
* принимает решение об отправке извещения

#### Предметной области
* взаимодействует с нужными объектами
* посылает подтверждение результата

#### Инфраструктурный
* рассылка
* экспорт

## Модули
### Цели
* уменьшить смысловую сложность
* удобно прослеживать архитектурные решения через связи модулей

### Характеристики
* низкая внешняя зависимость и сильная внутренняя связанность
* помогают строить все так, чтобы не нарушать границ модуля
* позволяют развивать модуль внутри модуля
* должны входить в единый язык
* должны рассказывать историю системы

### Ловушки инфраструктуры
* нельзя разделить концептуальный объект на части (Razor, WinForm)
* обязательный пакеты накладывают ограничения

### Парадигмы моделирования
**Объектная** - простота,  популярность, комьюнити  необъекты в объектном мире (логическая). Зависим от математических соглашений
**Логическая** - необъекты в объектном мире.
**Функциональная**

#### Смешение парадигм. Советы
* не противостоять парадигме реализации (искать то, что будет соответствовать)
* полагаться на единый язык
* не зацикливаться на UML
* подвергать все сомнению
* исчерпать все в рамках текущей парадигме

# Цикл существования объектов модели
Каждый объект имеет цикл существования (создание - модификация - архив - удаление).
Существуют временные и долгоиграющие объекты (со сложными связями, изменением состояния, подчиняется инвариантоности)

## Трудности управления объектами
* поддержание целостности на этапе существования
* предотвращение излишней сложности в управлении циклом существования

**Шаблоны для разрешения трудностей**
* агрегаты - помогают в поддержании целостности объектов
* фабрики - создание - восстановление сложных объектов
* хранилища - поиск и извлечение

## Агрегаты
**Проблема**
При внесении изменений в объекты модели со сложной системой ассоциаций можно получить несогласованные данные. Необходимо соблюдать инварианты к тесно связанным группам объектов, а не к отдельным объектам. Если переборщить со схемами блокирования, то будут проблемы с параллельной работой.

**Помогают решению**
* знание предметной области
* знание частоты смены экземпляров объектов
* построение модели с большой свободой в местах интенсивной передачи конкурирующих данных
* построить модель, принуждающую к соблюдению инварианта

**Корень проблемы**
* нечеткие границы

**Правила для транзакций, вносящих изменения и в первичные, и в связанные объекты**
* абстракция для инкапсулрующих ссылок в пределах модели (Агрегат)

**Агрегат состоит:**
**Корень агрегата** (корневой объект) - это конкретный объект-сущность
 * сущности снаружи агрегата ссылаются на него
 * объекты внутри границы могут ссылаться друг на друга
 * сущности внутри корневого объекта могут быть локально индивидуальны, но только в пределах границ. Снаружи доступа нет.
      Пример: Шины у машины. Внешний номер машины - известен за пределами границ. Уникальность конкретной шины необходима только в рамках конкретной машины.

**Из взаимосвязей между объектами агрегата можно составить инварианты - Правила совместности, которые должны соблюдаться при любых изменениях данных. это правило должно контролировать при завершении любой транзакции**

### Правила создания агрегата
* корневой объект имеет глобальную идентичность и несет ответственность за проверку инвариантов
* не корневые объекты-сущности имеют локальную идентичность
* ничто, кроме корня агрегаты не открываются за пределы границ для сохранения
* корневой объект может передавать ссылки на внутренние объекты-сущности другим объектам, НО во временное пользование без хранения или фиксирования (на время существования операции)
* корневой объект может передавать копию объекта-значения. Его дальнейшая судьба не важна.
* только корневой агрегат можно получать по запросами к источнику данных. все остальное разрешается извлекать по цепочке связей
* объекты внутри агрегаты могут хранить ссылки на корневые объекты других агрегатов
* удаление удаляет все в границах агрегата
* при изменении любого объекта внутри границ агрегата удовлетворятся все инварианты агрегата
**Пример инварианта - сумма не больше предела**

## Фабрики
Фабрики обеспечивают инкапсуляуцию внутри агрегата: Когда создание объекта перекладывается на клиента это:
* не соответствует принципу SRP
* утечка обязанности из предметной области
* брешь инкапсуляции

**Объект необходимо дистилировать, пока в нем не останется ничего, что имеет отношение к его сути и его роли в транзакциях**

Создание сложных объектов - это обязанность предметной области, но не объектов, выражающих модель
**Обязанность фабрики - создавать объекты**
* интерфейс объекта должен инкапсулировать реализацию
* фабрика инкапсулирует знания для создания сложного объекта или агрегата

**Шаги создания сложного объекта и агрегата**
* передать обязанности создания объекта фабрике (задача по созданию передана отдельному классу)
* создать интерфейс инкапсулирующий сложные операции и не требует от клиента ссылаться на конкретные классы
* создайте агрегат как единое целое с соблюдением инварианта

**Требования к фабрикам**
* один метод создания - должен гарантировать соблюдение инваринта
* создавать объект целиком в корректном состоянии (для сущности создается целый агрегат с соблюдением всех инварианта, можно позже добавить второстепенные элементы; для объекта-значения - это значит, что все атрибуты инициализируются всеми окончательными корректными значениями)
* если есть возможность ввода некорректного значения должна инициироваться исключительная ситуация
* абстрагировать фабрику нужно к желаемому типу, а не к конкретному классу

### Выбор фабрик и их местонахождения
* если добавляются элементы внутрь уже существующего агрегата - в корневом объекте агрегата создать фабрику
* если объект участвует в порождении другого объекта, но не владеет им после создания - в него можно поместить метод-фабрику для создания не основного объекта
* фабрику помещаем только в объект, где сильная естественная связь с порождаемым объектом
* если нужно скрыть реализацию или сложность процесса создания, но нет естественного объекта для инкапсуляции - нужна специальная фабрика или служба. Такая автономная фабрика порождает агрегат, вызывая ссылку на корневой объект (и инвариант соблюдает)
* если нужна фабрика для внутреннего объекта по отношению к агрегату (например корень не подходит) - фабрика, НО! на порождаемый объект возможны только временные ссылки извне агрегата.

**Когда достаточно конструктора**
* класс является типом, не входит в иерархию, не используется полиморфически
* клиенту нужно знать реализацию объекта (например для выбора стратегии)
* все атрибуты объекта доступны клиенту (в конструкторе не создаются никакие новые объекты)\
* простое создание объекта
* общедоступный конструктор должен следовать тем же правила, что и фабрика
**Конструктор в конструкторе  - это плохо. Конструкторы должны быть простыми**

### Проектирование интерфейса
* каждая операция единая и неделимая (все данные для создания передаются в одну коммуникацию) Важно решить, что делать с исключениями (нужен единый стандарт)
* фабрика должна быть связана со своими аргументами . Если неосторожно выбрать набор входных параметров, то может получиться паутина взаимосвязей(если сразу вставляются значения - низкая зависимость, если при конструировании берется только часть от объекта, то зависимость становится сильнее)
* используйте абстрактный тип аргумента, а не конкретные классы. (фабрика привязана к конкретному типу продуцируемых объектов, нет нужды привязывать в конкретным параметрам)

**Самые безопасные параметры - с нижних уровней архитектуры или близкородственный к генерируемому так что между ними не создается новая взаимозависимость (товарный заказ - позиция товарного заказа - товар)**

### Где реализовывать логику инвариантов
* проверка выполнения инвариантов - фабрика. Идеальный случай: фабрика делегирует проверку объекту. 
* иногда можно вынести в саму фабрику, не загромождая создаваемые объекты, например, для правил распространяемых на много объектов
* можно вынести в саму фабрику если логика не будет меняться в течение существования. например все характеристики у объекта-сущности - неизменяемые объекты-знаечния, тогда незачем тащить логику проверки инварианта в объект.

### Отличие фабрик-сущностей от фабрик-объектов-значений
* объекты-значений создают в окончательном виде и фабрика должна задавать полное описание продукта
* фабрики-сущности склонные работать с самыми существенными атрибутами для создания корректного агрегата и соблюдения инварианта, а детали позже. Плюсы: контроль над процессом создания индентификатора.
* если необходим извне получать уникальный идентификатор, то его контроль удобно возложить на фабрику. Даже в случае автогенерации ключа(база, внешний механизм) - фабрика знает, куда его поместить и откуда запросить

### Восстановление хранимых объектов
Восстановление объекта в памяти - это сбор отдельных частей заново в единое целое. (Середина жизни цикла объекта)
* восстанавливает объект-сущность, не присваивая идентификационный номер (иначе это было бы не предыдущее состояние, а новый объект, поэтому идентификатор должен сохраняться во входных параметрах фабрики)
* восстанавливающая объект по-другому обрабатывает нарушение инварианта
    * при создании фабрика обычно просто сбрасывает объект
    * для восстановления должна быть схема разрешения противоречий

## Хранилища
Для проектирования объектов разумно сочетать поиск и отслеживание связей (поиск по идентификатору или подтянуть по связи)
* создание нового экземпляра на основании сохраненных данных - это по сути восстановление объекта
* объекты-значения подтягиваются через связи (не стоит тянуть напрямую из источника)
* глобальный поиск по атрибутам лучше реализовывать для сущностей
    **Если нужно глобально найти объект-значения, возможно, это сущность**
* открытое использование технической инфраструктуры механизма доступа к источнику данных захламляет модель
**Обращение к любому объекта, внутреннему по отношению в агрегату, может выполняться только через корень агрегата**

**Хранилище** - это архитектура инкапсулирования технических решений. это объекты определенного типа в виде множества. Вроде коллекций: добавление, удаление, помещение в БД, методы ответа из БД на запросы клиентов

Что делать:
* для каждого типа объектов с глобальным поиском создаем посредника, который создаст иллюзию того, что все объекты типа объединены в коллекцию и находятся в оперативной памяти
* налаживаем доступ через хорошо известный(общий) глобальный интерфейс
* реализуйте методы добавления, удаления объектов, скрывающие работы с БД
* реализуйте запросы
* реализуйте хранилища только для тех, к корневым агрегатам которых нужен доступ
* **клиент опирается на модель, операции обработки данных на хранилище**

### Запросы к хранилищам
Для создания гибких запросов можно строить запросы на основе **спецификаций**. **Спецификация** - это способ описания того, что нужно без углубления в то, как делается. Создается объект, делающий этот выбор

### Клиентам безразлична реализация хранилищ, а разработчикам нет
Не будь соплей, умей работать с источникам данных, знай особенности внутренней обработки запросов и команд

### Реализация хранилищ
* абстрактный тип (generic)
* извлекайте преимущество из независимости клиента (отдельные реализации кеширование, подмена источника, моки)
* оставить контроль транзакций клиенту (пусть клиент фиксирует транзакцию)
* хранилище - это инфраструктурный уровень

### Связь с фабриками
Фабрика - это начало существования объекта, Хранилище - середина (находит и извлекает старые объекты)

### Проектирование объектов для БД
* если база основное хранилище  - нельзя сильно разводить модель БД и объектную (обсуждаемый процесс)
* процессы вне объектной системы не должны иметь доступ к хранилищу объектов

# Работа с языком. Расширенный пример
* нужно стремиться к формулировке утверждений: Должна, участвует, цель, этап
* стремиться к незагромождению моделей (не включать слишком много)
* усовершенствование моделей, проектирование и реализацию идут итерационно
* нужно стремиться обрисовать процесс

## Изоляция предметной области (Возможный первоначальный план)
* выделение многоуровневой архитектуры
* выделение уровня предметной области
* определение прикладных функций для операционного уровня
    * служба регистрации событий (классы координаторы без функций)

## Отделение сущностей от значений
Рассмотреть все объекты и выяснить, кто индивидуальная единица, а кто набор значений:
**Сущность**
* есть ли идентичность (признак)
* должна пониматься разница объектов (как их сравнивать и отличать)
* каждый ли объект значим (его изменение, существование)

**Объект-значения**
* если есть гипотетическая идентичность, то достаточно ли будет ее внутри границ агрегата
* зависит ли объект от более масштабного (значимого), однозначная ли это зависимость
* есть ли история и непрерывность существования

## Проектирование ассоциаций
Определить приоритетную ассоциацию(от чего идем)

## Границы агрегатов
* каждая из выявленных сущностей должна стать корнем агрегата в своем агрегате
* сформировать вокруг корня все, чего не существует без корня (например, все, что он порождает или зависит от него, или является его описанием)

## Выбор хранилищ
* Определить, кто из агрегатов имеет право на хранилище (для тех, кого надо выбрать откуда-то, создать, найти)
* Нарисовать границы агрегатов в модели (все, что снаружи  - новый агрегат)
* пройти по сценариям программы, чтобы убедиться в эффективности решений.

## Создание объектов
* создать фабрику для корня агрегата (Абстрактную или метод)
    * в конструктор передать все атрибуты, определяющие уникальность 
    * возможно включить генерацию уникального идентификатора
    * вернуть из фабрики корень агрегата с "пустыми" объектами-значениями
    * можно включить внутрь создание зависимой сущности объекта 

### Перерыв на рефакторинг
* можно некоторые объекты или ссылки заменить на запрос к источники (например)

### Модули
* Выделить модули на основании связных понятий и целей проекта, а не технических особенностях реализации

### Применение новых требований от заказчика
* Выделить предохранительный уровень для работы со смежными системами (класс для обозрения необходимых возможностях в терминах модели)
    * Определить службу для каждый функции необходимой от внешней системы (реализовать их все через контроллер или хэндлер, только обращение к службе)

### Усовершенствование модели
* переработка понятий со специалистами. Важно не нарушать инкапсуляции и границ

### Определение быстродействия
* выявить возможные утечки и "дыры"
* определить, где есть место для кеша

# Углубляющий рефакторинг
Удобство внесения измерений в процессе получения знаний - задача гибкой архитектуры. Простор для эксперимента.
**Процесс познания:** важно уметь подходить творчески, но и иногда следовать существующим шаблонам

# Качественный скачок
Распределение выгоды от рефакторинга имеет нелинейный характер. Наиболее важные качественные улучшения происходят скачкообразно и волна распространяется по проекту. Накопленные знания перерабытываются в компактную форму модели. **Скачок - нестрандартный прием**

## История успеха (Описание задачи.)
Обслуживание работы инвестиционного банка

## Модель неплоха, но:
* имеется база кода, которая была реконструирована на основе модели
* сформирована модель
* появляются проблемы с добавлением новой функциональности, расчетами, скруглениями

## Качественный скачок
* выясняется существование неправильно понятой связи (Додуманной, не выявленной у специалистов предметной области)

## Углубленная модель
* выделятся ранее скрытое понятие
* выясняется, что введенное понятие(вместо необходимого) было непонятно специалистам предметной области
* перестраивается модель
* удалена лишняя связь

## Трезвое решение
* предполагается отставание от графика, а модель затрагивает многое реализованное
* руководитель задает вопрос "Будет ли движение вперед без этого решения"

## Воздаяние (плюсы от рефакторинга)
* прекратили неожиданные изменения в требованиях программы
* ввелось новое понятие в единый язык: даже специалистов предметной области

## Потенциал
* самые важные достижения работают такими скачками

## Концентрация на основах
* нельзя насильственное вызвать качественный скачок - это парализует работу
* чаще всего понимание возникает из мелких изменений
* прорабатывайте единый язык и сосредоточиться на переработке знаний
* нащупывайте важнейшие понятия предметной области
* выражайте понятия в явном виде
* делайте архитектуру гибкой
* выполните дистилляцию моделей
* не чурайтесь мелких изменений
* не теряйте бдительности, но и не стопорите работу, заглядывая далеко вперед

## Каскад озарений
* углубленная модель может открыть перспективы для архитектуры (например могут быть найдены неуклюжие решения)
* с этими элементами работа ведется по инструкции в этой главе

# Перерод неявных понятий в явные
Этапы создания углубленной модели
* выделить ключевые понятия предметной области, пригодной для моделирования
* последовательные приближения и рефакторинг

## Извлечение понятий
* Приглядываться к языку и исключить неуклюжие понятия

## Внимание к языку
* названия для некоторой совокупности данных можно почерпнуть из отчетов
* помощь пользователей уточняющих понятия
* нужно внимательно слушать специалистов, прислушиваться к терминам
* нужно выявлять скрытые понятия. некоторые могут скрываться за глаголами
* новое понятие - это понятие-ориентир для переработки знания

## Выявление узких мест
* выявление "неудобных" мест (например, там постоянно появляются ошибки)
* выявить пропущенные понятия
* признаком пропуска понятия или неуклюжести может быть сложность вычислений
    * получили сложность вычислений - > необходимо уточнить, что специалист предметной области концентрируется на том же понятии, что и вы

## Размышления над противоречиями
Различные специалисты имеют свои взгляды на предмет, основанные на личном опыте. Если в словах специалиста есть противоречие, то есть источник(ключ) к угулбленной модели. ДИАЛЕКТИКА!

## Чтение книг
Чтение специализированных книг, как способ погружения в предметную область, как способ новых понятий, как поиск знаний

## Моделирование не очевидных понятий
### Явные условия-ограничения
Условия-ограничения образуют важную категорию понятий модели. Они существуют в неявном виде и их перевод в явный вид улучшают концептуальную архитектуру.

Ограничения вписываются в объект и их можно вывести в собственный метод
Плюсы:
* имя для ограничения более понятно, чем просто условие
* возможность расширения ограничения без нагромождения
* возможность компоновки с более сложными условиями
* принцип единичной ответственности
Минусы:
* для проверки ограничения используются данные, которые без него излишни для определения объекта
* в нескольких объектах есть связные правила и они требуют наследования или дублирования
* когда ограничения затмевают основные обязанности объекта

### Процессы как объекты предметной области
Процедура - это не главный аспект.
Главный - это объект, процедуры инкапсулируются объектами
Один из способов реализации процесса - это служба, которая может инкапсулировать сложные алгоритмы.

**Признаки того, что процесс нужно выделять в объект, а не инкапсулировать**
* говорят ли об этом специалисты предметной области или это внутренняя реализация. Если говорят специалисты - нужно присмотреться

Условия-ограничения и процессы - это путь к гибкой архитектуре

## Спецификация
Существуют правила, которые регламентируются бизнесом(сложные) и которые должны реализовываться на уровне предметной области, а не в объекте

**Реализация правил прикладной модели(деловые регламенты) часто не вписываются в рамки "низких" функций сущностей и объектов-значений, а обилие и разнообразие их может исказить смысл объекта предметной области. Вынесение этих правил из уровня предметной области  - хуже, так как тогда код уровня не выражает модель, и, как следствие необходимо выделить условие в отдельный объект**

Этапы выделения в отдельный объект: 
* представляют тест на истинность. Объекты, возвращающие булево значение
* выделяем его в объект-значения
* объект оценивает другие объекта, проверяет истинность применимого агрегата
    сущность - тест - сущность

* **Спецификация** задает ограничение на состояние другого объекта, которое может возникнуть, а может и не возникнуть.
* Спецификация может проверять любой объект на соответствие некоторым критериям
* **Спецификация - это предикат**, которые определяет, удовлетворяет объект критериям или нет. Как следствие, нужно создать набор явно определенных предикатов подобных для решения задач

Преимущество:
* правило на уровне предметной области
* фабрика может сконфигурировать спецификацию, используя информацию из других источников (БД, регламентные данные)

### Применение спецификаций
* проверка пригодности (соответствие правилу)
* отбор по запросу (выбор набора на основе предыдущей проверки)
* создание по некоторому заказу (например создание при удовлетворении некоторых правил. генерация, к примеру)
**Реализация**
* можно реализовать общий интерфейс для всех спецификаций и передавать в конструктор правила, тоже реализующие определенный интерфейс
* можно использование спецификации реализовать в хранилище

# Гибкая архитектура
Если элементы архитектуры монолитны и отдельные части нельзя перекомбинировать в новое целое, тогда дублирование становится неизбежным. Каждое такое место создает потолок сложности алгоритмов. В этом случае для рефакторинга нет места.

**Архитектура, приглашающая к изменениям - гибкая архитектура**
* **гибкая архитектура** - это дополнение к углубленному моделированию: если нашли новое понятие, то необходимо как можно проще его внедрить.  Удобно для клиентов, которые не будут меняться, если все построено на интерфейсах (итеративно)
* гибкая архитектура выражает углубленную модель в ее основе и раскрывает ее потенциал

**Вспомогательные шаблоны**
* единый язык
* информативные интерфейсы
    интерфейс и его методы должны предоставлять полноту картины для клиента. не должно быть необходимости проваливаться в методы и смотреть реализацию. Имя должно описывать задачу и результат, но не способ
* функции без побочных эффектов
* контрольные утверждения
* изолированные классы
* концептуальные контуры
* замкнутость операций

## Функции без побочных эффектов
все операции можно разделить на команды и запросы: 
* **Команда** вносит изменения в систему. 
* **Запросы** оставляют систему без изменений.

**Побочный эффект** - последствие действия. Это изменение в системе, которое влияет на будущие операции.
Взаимный эффект правил комбинаций и вычислений непредсказуем. В этом случае программисту нужно знать, что будет после использования операции. В этому случае теряется смысл абстрагирования

Операции, возвращающие результат, не создавая побочных эффектов, называются **функциями**. Можно много раз и ничего не изменится

### Рекомендации
* разграничить функции и команды
* оформить, как разные операции
* методы изменения проще и не возвращают результат
* все запросы и вычисления выполнять в методах без побочных эффектов
* все операции объектов-значений должны быть без побочных эффектов
* операции, где сложный алгоритм смешивается с изменениями состояния факторизуются в отдельные операции
* сложные операции могут быть вынесены в отдельный объект-значение
* если операция дает что-то новое в результате, то это объект-значение

## Утверждения
* Утверждения используются для команд и позволяют что-то сделать
* Разработчик должен понимать последствия произведенного утверждения. Часто эту задачу решают информативные интерфейсы.

**Инварианты классов - это утверждения о состоянии объекта в конце каждой операции (пост-условие)**

### Рекомендации
* инварианты позволяют охарактеризовать смысл класса
* нужно формулировать пост условия операций
* нужно формулировать инварианты для классов и агрегатов, включать их в документацию
* строить модель со связным набором понятий для формулирования утверждений
* частично могут решить задачу модульные тесты

## Концептуальные контуры
* Монолит благоволит дублированию. Не предоставляет полной информации о возможностях. Мельчайшие изменения ведут к усложнению клиентского кода 
* Если переборщить с разбиением, то можно потерять суть, заложенную в объекте(Половина сосиски - это уже не сосиска)

**Когда модуль непросто приспособить к новым открытым понятиям необходим глубокий рефакторинг**
* внутренняя связность и низкая внешняя зависимость применимы к понятиям и коду. 
* при принятии решений не нужно сползать в только технический взгляд на вещи, нужно ответить на вопрос: "Это техническая уловка в угоду зависимостям в коде или отражение смыслового контура в предметной области: если сложение объектов имеет смысл на уровне предметной области"

**Каждый объект должен представлять собой законченное понятие (Whole value)**

### Рекомендации
* разбивайте элементы архитектуры (операции, интерфейсы, классы, агрегаты) на связные единицы, учитывая понимание границ предметной области
* наблюдайте за направлениями изменений, осями стабильности в ходе рефактринга
* ищите концептуальные контуры, по которым проходит расслоение

### Цель
* создать набор интерфейсов, которые можно сочетать между собой для составления интерфейсов

## Изолированные классы
* Ограничение паутины взаимосвязей входит в задачи модулей и агрегатов.
* Зависимость от других классов внутри одного модуля менее вредоносна, чем внешние взаимосвязи

**В пределах одного модуля сложность взаимосвязей увеличивается и, как следствие, смысловая перегрузка и снижение сложности архитектуры, понятной разработчику. Вероятнее всего с возрастающей сложностью имеют место неявные понятия**

### Рекомендации
* можно уменьшить количество связей до нуля для важного подмножества
* каждая взаимосвязь и зависимость должны быть рассмотрены (факторизация)
* **низкая внешняя зависимость - это важнейшее свойство** и, как следствие, нужно удалять и исследовать все внешние зависимости, пытаясь сделать класс самодостаточным, как следствие, можно понимать объект отдельно от других
* выделять сложные классы вычислений в отдельные классы или объекты-значения
* устранение взаимосвязей - это не сведение всех элементов модели к самым приметивным

**большое количество манипуляций с парой объектов помогают прояснить природу их взаимосвязи**

## Замкнутость операций
Там, где уместно, определяйте операцию с тем же типом возвращаемого объекта, что и тип аргумента. Если объект
, реализующий операцию, имеет состояние, используемое в вычислениях, то объект - это объект операции, поэтому аргументы и возвращаемое значение должно быть того же типа, что и объект. Эта операция **замкнута** относительно множества экземпляров этого типа, как следствие, не зависит от других понятий

### Рекомендации
* чаще всего применяется в операциях объектов-значения, т.к цикл существования
* иногда применяется к объекту-сущности (например, нужно вернуть у работника, его начальника - тоже тип работник)
* операция может быть замкнута вокруг абстрактного типа, в этом случае аргументы могут относиться к разным классам
* делегирование (итераторы)

## Декларативная архитектура
Это способ написания программы, как спецификации. Управляется точечным описанием свойств: рефлексия, автоматически генерируемый код, логическое программирование
Минусы:
* невыразительность языка
* средства генерирования препятствуют итерационному циклу разработки: вставляют автоматически сгенерированный код в написанный вручную и повторное генерирование действует разрушительно

### Специализированные предметные языки
* можно разработать специализированный предметный язык для задачи

### Декларативный стиль архитектуры
Часть декларативной архитектуры: информативный интерфейс, утверждения, функции без побочных эффектов. Эти элементы сочетаемы и являются частью гибкой архитектуры

### Расширение спецификаций в декларативном стиле
Сочетание спецификаций через логические операции
* нужно создать абстрактный класс для работы спецификаций любого рода
* возможно применение предохранительного оператора
* можно расширить операторами (and, or и т.д)

## Углы атаки
Выделение подобластей: 
* выделяем сложные правила в модели
* определяем специальную математику

Пример кредитная математика:
* определяем запрос от команды
* выявить неявные понятия (может ложатся на логику, но не существуют)
* ответить на вопрос: можем ли сделать зависимость (одного из объектов) объектом-значением
* сможем ли замкнуть операцию на объект-значение
* составить утверждения относительно объектов-значения

Ход рефакторинга
1. сложные объекты инкапсулируем в специальные объекты-значения с функциями без побочных эффектов
2. операции-команды должны быть просты и характеризоваться утверждением
3. понятия модели должны быть независимы
4. в операциях должен быть минимум новых типов. некоторые замкнуты
5. выявлять знакомый рабочий протокол (не изобретать новый процесс)

# Применение аналитических шаблонов
**Аналитические шаблоны** - это группа понятий, представляемую часто используемую конструкцию в моделировании предметной деятельности, при этом могут относиться к одной или нескольким предметным областям
* нужно быть готовым к компромиссам, но не отступать от проектирования по модели

**Архитектурный шаблон - способы взаимодействия между классами, адаптированные для решения задачи**

# Шаблоны и модель
Разница между шаблоном предметной области и архитектурным шаблоном: архитектурные шаблоны используются на уровне предметной области, но если они удовлетворяют решаемой задачи. Но рассматривать их применение нужно на двух уровнях: предметной области и технические решения

## Стратегия
Есть процессы без технической мотивации, но зато они имеют прямой смысл в соответствующей прикладной деятельности, и нужно обеспечить альтернативные процесс, то решение этой проблемы - **Стратегия**

### Рекомендации
* выделить изменчивую часть процесса в отдельный объект
* отделить правила от операций
* реализовать правило или процесс согласно шаблону

**Применимость со стороны DDD**-возможность выражать концепцию, правило, понятие
**Минусы:** клиент должен знать о наличии разных стратегий
**Правило:** стратегия должна реально существовать в процессе

## Композит
Компоновка объектов в древовидные структуры "от части к целому". Композит позволяет клиентам единообразно представлять как отдельные объекты, так и их компоненты
* если в модели не отражена родственная связь связь между вложенными контейнерами, то на каждом уровне иерархии нужно дублировать код. Фактически клиенты взаимодействуют с разными уровнями иерархии, хотя для клиента не разницы

Перед применением необходимо определить относится ли шаблон к реальной предметной области. Удалось ли найти абстракцию, в которой все части принадлежать к одному концептуальному типу

### Правило
* определить абстрактный тип, заключающий все члены композита
* реализовать методы для возвращения агрегированной информации о содержании объектов
* листья реализуют методы в соответствии с атрибутами
* клиентам не нужно различать листья, они имеют дело с абстрактным типом
 **Плюс:** одинаковое поведение на каждом структурном уровне
**Требование к шаблону:** сообщать нечто концептуальное о предметной области

# Углубляющий рефакторинг
Многократный и многогранный процесс

## Принципы DDD
* жить в предметной области
* смотреть на вещи под разными углами
* поддерживать диалог со специалистами

## Инициирование
Рефакторинг начинается разными методами: проблема в коде, сложные участки с постоянными проблемами, проблема предметной области, результат обучения и более глубокого понимания проблемы

## Исследовательские группы
Поиск усовершенствования:
* решит мелкое изменение
* решит поиск новой модели

### Решения для новой модели
* взять программистов, знакомых с предметной областью
* взять специалиста предметной области
* провести мозговой штурм (event storming)
* добиться понимания и осознанности у специалиста предметной области

### Необходимые детали
* самоорганизация (без сложных структур): несколько человек собрались и обсудили
* время (2-3 совещания)
* единый язык

## Предыдущие наработки
В качестве источника могут выступать книги, статьи, существующие понятия, аналитические шаблоны от предшественников, применение логики, математики

## Архитектура для разработчиков
Гибкая архитектура хороша, выразительна и упрощает жизнь разработчиков

## Расчет времени
Постоянный рефакторинг - это best practics. Больше дыр - больше финансовых потерь.
**Предпосылки для рефакторинга:**
* архитектура не отражает представлений группы о предметной области
* важные понятия существуют в неявном виде
* есть возможность сделать какую-то часть более гибкой

**Не нужно гибкой архитектуры, демонстрирующей техническую возможность**

## Кризис, как потенциальная возможность
Кризис - это когда докопались в процессе углубленного рефакторинга до того, что рушит сформулированную модель и, как следствие, изменения, которые исправят невыразительность существующей модели

# Стратегическое проектирование
При возрастании сложности системы возникает необходимость управления и восприятия большими моделями
* необходимо добиться модульности, которая не потеряет преимуществ интеграции (отдельные части работают совместно, способствуя координации операций)
* архитектурные решения должны основываться на стратегических решениях, чтобы уменьшить взаимозависимость отдельных частей и улучшить наглядность работы системы, не теряя ядра системы

# Поддержание целостности модели
* согласованность модели, при которой каждый термин имеет однозначный смысл и ни одно правило не противоречит другому называется унификацией
* если нет логической согласованности, то модель не имеет смысла. В идеальном случае любое логическое утверждение о предметной области было бы непротиворечивым
* поддержание такой унификации требует больше усилий, чем дает пользу. Полная унификация невозможна или затратна и, как следствие, нельзя все потребности удовлетворить одной моделью

Необходимо использовать способ, обозначающий границы и взаимоотношения между объектами. Для этого выделим:
* **ограниченный контекст** - диапазон применимости
* **карта контекстов** - общий вид контекстов и взаимоотношений между ними
* **непрерывная интеграция** - унификация модели
* **общие ядра** - отношения между этими сущностями определяется в ограниченных контекстах
* **отдельное существование**  - косвенно существование модели

# Ограниченный контекст
В любом крупном проекте возникает необходимость работать с несколькими моделями, но если попытаться соединиться все в одну, программа становится ненадежной: трудной в понимании, непонятно в каком контексте модель не должна применяться

**Контекст модели (BOUNDED CONTEXT)** - это набор условий, которые должны выполняться, чтобы можно было утверждать, что термины модели имеют конкретный четкий смысл

**Рекомендации**
* определить контекст, в котором применяется модель (часть вызова, результат мозгового штурма, модель для интеграции, часть базы данных)
* установите границы в соответствии с организационной структурой группы, особенностями операций в разных частях приложения, организацией базы данных
* следите за согласованностью модели в установленных границах
* не отвлекайтесь на внешние проблемы

**Характеристики**
* **Ограниченный контекст - не модуль!** Модули не всегда пытаются ограничить контексты, они используются для организации модели. 
* ограниченный контекст ставит пределы применимости какой либо модели, чтобы разработчики поддерживали единообразие и согласованность и понимали в чем она состоит. 
* внутри контекста модель должна быть унифицированной, что вне границ - "не на нашей стороне"
* интеграция за границы требует трансляции (дто, маппинг)
* карта контекстов позволяет расчертить крупномасштабную архитектуру
* единство модели внутри ограниченного контекста поддерживается непрерывной интеграцией

## Рaспознавание дефектов внутри ограниченного контекста
**Симптомы**
* несоответствие запрограммированных интерфейсов (неожиданное поведение от метода)
* путаница в языке
* дублирующиеся понятия (признак таких понятий при изменении одного понятия, второй нужно проанализировать и изменить). 
* ложные родственники (используют один термин для обозначения разных понятий и, как следствие, разные группы программистов будут вмешиваться в контексты друг друга)

## Непрерывная интеграция
Определив ограниченный контекст, следует поддерживать его в хорошем состоянии. При работе в одном контексте большого числа разработчиков, он фрагментируется и распадается на части. Если разбивать контекст на части, что в нем теряется уровень интеграции и связности

**Непрерывная интеграция (CONTINUOUS INTEGRATION)** состоит в том, что вся работа в пределах контекста сливается воедино и приводится в согласованный вид достаточно часто, чтобы при появлении дефектов, они обнаруживались достаточно быстро

**Два уровня непрерывно интеграции**:
* интеграция понятий модели - через взаимодействие членов команды (разработка единого языка)
* интеграция программной реализации (через сборка - компиляция - тесты)

Непрерывная интеграция применима внутри любого ограниченного контекста, значит
**Цель непрерывной интеграции**
Целостность одиночной модели контекста

## Карта контекстов
Если между разными контекстами необходимо наличие связей, эти контексты имеют тенденцию просачиваться друг в друга

**Карта контекстов (CONTEXT MAP)** - средство на стыке управления проектом и архитектурного проектирования.
Естественный ход организации команды - по ограниченным контекстам (разделяют ценность контекста модели), подсистемам. 
и
**Рекомендации**
* определить все модели в контексте
* задать для каждой модели ограниченный контекст
* учитывать явные-неявные понятия модели подсистем, которые не являются объектно-ориентированными
* дать имя каждому контексту, включить имена в единый язык
* описать точки соприкосновения между моделями, явно задавая трансляцию для любого способа коммуникации и выделяя любые совместные ресурсы
* постройте карту существующей территории в любом представлении

**Шаги при обнаружении смысловых дефектов**
* завершить карту
* вернуться к листам противоречий, имея точный общий вид
* исправив небольшой дефект, ввести специальные процедуры для их целостности
* если не ясна связь, то выбрать близкий по смыслу шаблон и двигаться по нему
* не концентрироваться на мелочах, мелких проблемах, главное построить контекст
* изменения вносить в карту только тогда, когда сделаны реально

**Тестирование в границах контекста**
нужно и важно

## Организация и документирование карт контекстов
* у ограниченного контекста должно быть имя уникальное для всех разработчиков
* разработчики должны знать, где пролегают границы и знать, где чей контекст уже по наименованию модулей
* можно хранить карту как схему

## Взаимосвязи между ограниченными контекстами
### Общее ядро
* организация работы команд, работающих над разными частями единого приложения (или близко связанного)
* выбрать подмножество, над которым группы согласны работать вместе (часть базы-архитектуры). Эти элементы могут изменяться при согласии другой стороны
* выполнять регулярно непрерывную интеграцию
* прогонять тесты обеих групп
* не обновлять общее ядро слишком часто, как другие части архитектуры
* можно иметь у себя копию ядра, вносить изменения туда, а потом интегрироваться. 

**Цель** - уменьшить дублирование работы и сделать интеграцию проще

### Группы заказчик-поставщик
Верх передает что-то вниз на анализ
Одна подсистема снабжает данными другую.У каждой свой ограниченный контекст. Трансляция в одну сторону
* у нижней может быть право вето на изменения, если процедуры запроса изменений громоздкие, но при этом она во власти приоритетов верхней группы
* верхняя может приостановить работу из-за нижней (сомнительно)

Хорошо работает шаблон, когда обе группы под единым руководством.
**Решение противоречий**
* определить отношения между группами в процессе планирования
* нижняя часть может выступать как заказчик при планировании, принимать участие в выработке решения
* определить временные рамки
* совместно разработать приемочные тесты
* сделать нижних всегда доступными для верхних

**Важное**
* заказчик важен, но если их несколько, все приоритеты надо согласовывать
* должен существовать набор авто тестов, который позволит верхнему уровню вносить изменения без ущерба для нижнего

### Конформист
Как заказчик-поставщик, только без единого руководства. связь "вверх" - "вниз"
* верх главный,может не делиться ресурсами, не сообщает о планах
* низ обходится тем, что есть, подстраивается

**Решение**
* отказаться от мысли о помощи сверху - не строим ничего, основываясь на предположении, что верх что-то объяснит
* создать трансляционный уровень, если есть проблемы с моделями
* остаться на модели верхней группы (это в духе конформизма)

### Предохранительный уровень
Необходим при интеграции со старыми неподдерживаемыми системами, ну или существующими
* не всегда удобно и хорошо переписать, надо пробовать интегрироваться

**Проблемы**
* инфраструктурный уровень должен уметь работать с другими протоколами
* нужно работать с другой моделью предметной области
* можно неправильно интерпретировать данные другой системы
* лишняя работа для новой системы

**Решение**
Создать изолирующий слой в обе стороны, который будет транслировать между двумя моделями

#### Проектирование интерфейса предохранительного уровня
**Преимущества** - возможность абстрагирования операций другой системы

**Реализация предохранительного уровня**
Один из способов организации архитектуры предохранительного уровня - это фасадные объекты, адаптеры, трансляторы
**Фасадный объект**-- это альтернативный интерфейс некоторой подсистемы, который упрощает обращение и упрощает использование со стороны клиента. 
* нам известны функции другой системы, делаем удобнее взаимодействие с ним
* должен быть написан в соответствии с внешней моделью
* не изменяет представленной системы

Нельзя разбрасывать ответственность за трансляцию на разные объекты, иначе полученное не будет соответствовать ни нашей, ни внешней модели.
Фасадный объект относится к ограниченному контексту другой системы. Приспособлен к нашему.

**Адаптер** - объект-оболочка, позволяющий пользоваться не тем протоколом, который понятен реализатору операции, а другим

**Шаги**
* клиент посылает запрос адаптеру
* адаптер преобразует данные в семантически верные и адресует адаптанту
* ответ от адаптанта также преобразуется и опускается клиенту
* достигаем цели - организация трансляции между двумя моделями

Для каждой определяемой службы необходим адаптер, который поддерживает интерфейс службы и умеет делать запросы к другой системе или фасадному объекту

**Задача адаптер делает запросы, а задача транслятора делает преобразования**

**Рекомендации**
* предохранительный уровень может быть двусторонним (когда другая система делает запрос)
* если нужна коммуникация между двумя подсистемами. если к другой системе нет доступа, то средства коммуникации можно поместить между фасадным объектом и другой подсистемой. если фасадный объект можно интегрировать с другой системой напрямую, то коммуникационное звено можно поместить между адаптером и фасадным объектом.
* если есть доступ к другой системе коммуникации располагаем между фасадным объектом и адаптером
* если есть доступ к другой системе можно отрефакториться до более выразительных имен методов интерфейса
* если требования строги, приближаем решение к внешней системе, чтобы упростить трансляцию, но осторожно, не подвергая опасности целостность модели. возможно, нужно применить конформист
* если другая система проста или имеет четкий интерфейс, то фасадный объект может не понадобиться
* в предохранительный уровень можно добавить логгирование, некоторые рабочие функции
* иногда этот уровень может быть внутри своей системы, если в основе подсистем разные модели

## Отдельное существование
Если интеграция дорога, а отдача не всегда велика
Функциональные возможности не обязаны интегрироваться в единое целое, только потому что используются в каком-то случае совместно

Можно объявить ограниченный контекст, не связанный с другими контекстами. Нужные функции могут быть на уровне middleware или в интерфейсе, но совместного использования алгоритмической логики не будет как и пересылки между трансляционными уровнями будут стремиться к нулю

## Службы с открытым протоколом
Чаще всего в любом ограниченном контексте определяется по одному трансляционному уровню для каждого компонента за пределами контекста, с которым необходимо интегрироваться. Если интеграция на один раз, то подход с добавлением одного трансляционного уровня для каждой внешней системы позволяет предохранить модель с минимальными излишками. Если будет обращаться часто, то нужен гибкий подход

**Рекомендации**
* определить протокол, предоставляющий доступ к системе, как к набору служб
* сделать протокол открытым
* расширить протокол для новых требований

## Общедоступный язык
Речь идет про общий язык между двумя ограниченными объектами. Говорят по xml, про использование понятий известных обеим сторонам. например, стандарт H7 в медицине

## Унификация модели
Вероятнее всего никто не захочет отказываться от своей модели. Можно попробовать ввести общую абстракция. Если знания со всех сторон сбросить в кучу, то стройной модели не получится, но если знания переработать, то может получится полная унификация модели. **Противоречие может быть источником новых моделей**

## Выбор стратегии построения контекстов
Разбор взаимосвязей перед картой контекстов

### Уровень принятий решений или выше
Идеально, если решение принимается всей группой, но в любом случае решение должно быть донесено до каждого члена команды. Нужно принимать решение о разделении или расширении взвесив преимущества независимой работы против тесной интеграции, найдя компромисс

### Помещение себя в контекст
Представить, что будет, если зайти в контекст и нарушить границы

### Преобразование границ
**Преимущества больших контекстов**
* более плавная связь разных объектов и операций
* легче для понимания
* отсутствие трансляции между моделями
* общий язык стимулирует общение среди разработчиков

**Преимущества малых контекстов**
* снижаются издержки коммуникации разработчиков
* проще делать непрерывную интеграцию в малых группах
* большие контексты требует более универсальные и абстрактные модели и, как следует, требует более высокого уровня разработчиков
* небольшие модели могут обслуживать специальные потребности, соответствующие узкой подобласти

### Принятие того, что нельзя изменить: контуры внешних систем
Важно определить внешние контуры (старые системы, например) от собственной архитектуры. Такой контур не является ограниченным контекстом.

### Взаимоотношение с внешними системами
Возможны три варианта:
* отдельное существование (отказ от интеграции)
* конформист (не очень приятно, но иногда надо, например, система отчетности)
* предохранительный уровень

### Проектируемая система (своя)
Сколько контекстов нужно иметь? В каких отношениях?
**Решения**
* ввести один ограниченный контекст (для 10 разработчиков)
* если разработчиков больше десяти, то возможно имеет смысл подумать об общем ядре и вынести относительно независимые наборы функций в независимые ограниченные контексты. Если отношения между какими-либо контекстами в одну сторону, то определить отношения заказчик-поставщик
    * если есть конфликты между группами - можно двум контекстам вести отдельное существование. Если между этими контекстами необходима интеграция, то вывести трансляционный уровень, который сопровождается совместно

### Учет особых случаев отдельными моделями
Если есть внутренние жаргонизма, то они наносят вред общему языку и не должны существовать в рамках непрерывной интеграции. Самый большой риск - это внесение шума узкими моделями. Главный вопрос: так ли нужно это понятие? велика ли цена трансляции?

### Установка системы
Координация установки изменений одного контекста при неизменном другом. должен сохраняться трансляционный уровень

### Компромиссы
Поиск компромиссов между преимуществами интеграции в одно целое и минусами дополнительной координации

### Если проект в работе
Если необходимо влиться в работу над уже разрабатываемым проектом
* определить контексты
* построить практику вокруг текущей организации
* улучшать непрерывную интеграция вокруг контекстов
* развивать единый язык

### Преобразования (изменение связей, укрупнение, разбиение)
#### Слияние контекстов
* убедиться, что контексты удины по смыслу
* выработать порядок работы с общим ядром, правила именования модулей
* определить частоту обновления общего ядра
* выбрать небольшую подобласть(понятную и простую)
* изучить существующие интеграции и трансляции (лучше что-то транслируемое)
* выбрать одну модель и сделать рефакторинг другого контекста для приведения к совместному виду, можно взять еще связные модели, чтобы не потерять взаимосвязи, можно новую более глубокую модель
* сформировать группу из 2-3 разработчиков из обеих групп для выработки подробной модели области
* разработчики реализуют модель, совместно проработав детали
* разработчики берутся за интеграцию с общим ядром
* убираем трансляции
* можно просто перейти на модель одного из контестов, если какая-то предпочтительнее, и провести рефакторинг

#### От общего ядра к непрерывной интеграции (полная унификация двух контекстов)
* разделить процедуры для непрерывной интеграции между группами
* начать циркуляцию разработчиков между группами для самостоятельного формирования группы
* объявить **дистилляцию** каждой модели
* перелить смысловое ядро предметной области (Core Domain) в общее (Shared kernel)
* увеличить частоту встреч для непрерывной интеграции
* по мере того, как общее ядро приближается к точке, в которой оно включит в себя оба бывших ограниченных контекста,получим ситуация, когда получим ситуацию две группы разработчиков с общей базой кода, которую они непрерывно интегрируют

**Слияние моделей смыслового ядра**
* можно придерживаться одной модели, делая другую совместимой с ней
* можно создать новую модели и приспособить оба контекста к использованию ее
    * разработка углубленной унифицированной модели сложная задача. надо сразу же формировать новый единый язык

#### Вытеснение устаревшей системы
* стратегия тестирования (золотой тест)
* определить специфические функции старой системы, которые можно добавить в новую систему за одну итерацию
* определить дополнения, которые понадобятся на предохранительном уровне
* реализовать
* установить
* удалить лишние части предохранительного уровня
* вырезать неиспользуемые модули старой системы
* прогнать тест

#### От открытого протокола к общедоступному языку
* определить существует ли единый язык
* если нет языка, выделяем смысловое ядро системы (Core Domain), которая будет служить сервером открытого протокола
* использовать смысловое ядро, как основу коммуникации, подключив определенную парадигму обмена данными (JSON, XML)
* опубликовать язык (спецификации документации)
* опубликовать архитектуру
* построить трансляционный уровень для каждой подключающейся к вам системы
* переключитесь на новую систему

# Дистилляция
**Дистилляция** - это процесс разделения компонентов смеси с целью выделения основного вещества в той форме, которая делает его более ценным и полезным.
Построение модели - дистилляция моделей

**Задача** - выделить один особо ценный компонент(смысловое ядро)

**Функции дистилляции**
* помогает всем понять архитектуру системы и связи
* облегчает процесс коммуникации, выделяя ключевую модель обозримой величины
* задает направление рефакторинга
* фокусирует внимание на наиболее ценных частях модели
* помогает определиться с суб. подрядами, использование готовых компонентов, распределением задач

## Смысловое ядро
Если разработчики сосредоточены на конкретном модуле, то обмен знаниями ухудшается, мешает интеграции, возникает дублирование, система усложняется
Чтобы модель предметной области стала важной, нужно отшлифовать смысловое ядро
* в процессе планирования следует направить ресурсы на самые сложные и запутанные участки архитектуры

**Рекомендации**
* уменьшить модель до минимума
* найти смысловое ядро и сделать так, чтобы его можно было отличить от массы вспомогательных частей модели и кода
* выделите самые ценные и специализированные понятия
* ядро должно быть небольшим
* отправьте на разработку ядра лучшие карты
* вкладывайте ресурсы в другие части системы по уровню важности для поддержки дистиллированного смыслового ядра

## Эскалация дистилляции
**введение в предметную область** - передает основные понятия
**схематичное ядро** - помогает усовершенствовать коммуникацию и процесс принятия решений
**неспециализорованные подобласти (Generic Subdomain)** - можно работать отдельно
**выделенное ядро (segregated core)**-делает видимым ядро даже в коде, что облегчает будущую работу над моделью ядра
**абстрактное ядро (abstarct core)** - выражает фундаментальные понятия и отношения в чистом виде

### Неспециализированные подобласти
Области без которых существование модели невозможно, но которые не обладают основными понятиями, исключительно вспомогательными.
**Рекомендации**
* определить, какие мотивы не являются основным мотивом к написанию приложения
* выделить модели этих подобластей в модули
* после выделения не оставлять ни следа специфики приложения
* у этой области минимальный приоритет

**Варианты использования подобластей**
* купить готовый модуль
    плюсы: Меньше писать, сопровождение на стороне, возможно, код более надежен
    минусы: надо все равно изучить тему,нужен аудит, перегруженность кода, возможные проблемы интеграции
* общедоступная архитектура или модель
    плюсы: более проработана, есть документации
    минусы: перегруженность лишними элементами, несоответствие потребностям
* вынос реализации на аутсорсинг
    плюсы: важные сотрудники не заняты этим, вынуждает к интерфейсному проектированию
    минусы: затраты на согласие, аудит, затраты на тестирование
* собственная реализация
    плюсы: простота интеграции, только то, что нужно возможность привлечения временных разработчиков
    минусы: затраты на сопровождение и обучение, стоимость и время разработки

### Неспециализированный не значит хорошо переносимый
Нет необходимости всегда строить переносимые архитектуры (повторно используемые), но следует строго придерживаться общей концепции
**Почему надо отделить неспециализированные подобласти**
* затормозит развитие архитектуры, внося лишнее(в рамках концепции)
* специализированные модели ценнее сами по себе, а не в рамках общей модели

### Управление рисками в проекте
Выделим на первый план высокий уровень риска - смысловое ядро

## Введение в предметную область
Введение в предметную область фокусируется на общих характеристиках модели предметной области
**Введение в предметную область** - это концептуальное видение(документ). Это ориентир для разработчика.

**Рекомендации**
* опишите смысловое ядро (страница), полезность как деловое предложение
* игнорировать то, что не отличает область от других
* показать, как модель служит разным интересам и создает баланс между ними
* написать документ как можно раньше и вносить изменения по мере развития знаний
* введение в предметную область определяет смысловое ядро в общих выражениях

## Схематическое ядро
Смысловое ядро может сделать более простым для понимания - схематическим ядром. Оно может быть нарисовано рукой, напечатано на 3D принтере, как удобно

### Дистилляционный документ
Документ со списком существенных концептуальных объектов и схемой их взаимного действия. Это минимальный набор, очерчивающий ядро

**Рекомендации**
* написать короткий документ, в котором описывается смысловое ядро и основные взаимодействия между элементами этого ядра
* Лучший способ снизить риск "усложнения области" - полный минимализм

### Разметка ядра
* посовещаться со специалистами предметной области
* определить главные разделы и понятия
* сделать карту смыслового ядра и связь с вспомогательными функциями
* разделать смысловое ядро и то что в него не входит

### Дистилляционный документ как методическое средство
**Изменение дистилляционного документа** - руководство к действию, индикатор значимости изменений в модели. Если изменения в модели или в коде влияют на дистилляционный документ, то это требует согласовании членов группы. Должен быть в актуальном состоянии у всех. Изменения за пределом ядра может вноситься без согласования, члены группы ознакомятся с изменениями в рабочем порядке

### Связные механизмы
Сложные механизмы работы должны быть инкапсулированы. Если в модели много алгоритмически(логически) сложных функций, значит, надо искать модель, упрощающую вычислительные механизмы. Нужно выделить **связную часть** механизма. Механизмы имеют вспомогательную функцию.

**Рекомендации**
* выделить механизм в отдельную библиотеку
* открыть механизм через информативный интерфейс

Модель смыслового ядра или неспециализированной подобласти - это формулировка факта, правила, задачи. Связный механизм - это реализация правил и их выполнение

### Сравнение связных механизмов и специализированной подобласти
* подобласть основана на понятиях смысловой модели, нужна для разгрузки смыслового ядра
* связный механизм не представляет предметную область, решает частную вычислительную задачу

### Когда механизм входит в смысловое ядро
Когда механизм является неотъемлемой частью программы, создающей ее конкурентную ценность. Например, особый алгоритм определения рисков, кредитной истории и т.д. Но, вероятнее всего, это ограниченный контекст в будущем.

### Дистилляция к декларативному стилю
Связные механизмы полезны, когда предоставляют доступ через информативный интерфейс с утверждениями, концептуально связанными и функциями без побочных эффектов, и, как следствие, оперирование осмысленными декларациями. Выделение специализированных областей делает код менее запутанным, связные механизмы инкапсулируют сложность, и, как следствие, позволяют сфокусироваться на модели без примесей.

## Выделенное ядро
Сложно разграничить подобласти и ядро. Элементы ядра могут быть тесно связаны с подобластями

**Рекомендации**
* определить понятия смыслового ядра от вспомогательных элементов
* определить вспомогательные элементы (даже неоднозначно определенные)
* усильте связность ядра, снижая зависимость от остального кода
* поместить в пакеты неспециализированные и вспомогательные элементы (даже если будут отделены сильно зависимые элементы)
* связные подобласти, являющиеся центральными выделятся в неспециализированные подобласти
* все что останется постепенно нужно выделать в специализированные подобласти, но на ранних этапах можно просто выделить в пакет

**Рефакторинг, порождающий выделенное ядро**
* определяет подобласть смыслового ядра
* выделяем, имеющие отношение к смысловому ядру классы в модуль
* отрезаем через рефакторинг данные, функции и возможности, не выражающие понятие непосредственно в пакет
* рефакторинг с целью упрощения взаимосвязей и взаимодействий в ядре, для минимизации и прояснения связи с другими модулями
* повторяем тоже самое на другой подобласти ядра

### Цена создания выделенного ядра
Выделение ядра иногда делает менее очевидными, даже более сложными, связи с классами не входящими в ядро
**Время создания ядра(выделения) - после выделения контекста**

### Эволюция коллективных решений
Решение о выделении ядра принимается только коллективом(самоорганизованным, скоординированным, дисциплинированным). Знания должны распределяться в группе. Архитектура должна быть гибкой для корректирования курса действий.

### Этапы выделения ядра
* показать схему процесса (документ, схема, рисунок). Сконцентрировать внимание на важном
* прописать связи

## Абстрактное ядро
Если между подобластями в отдельных модулях происходит интенсивное взаимодействие, то либо создается много ссылок между ними, либо организуется косвенное взаимодействие, что ухудшает наглядность модели

Нужно подумать над возможностью установить горизонтальные границы. Полиморфизм дает право игнорировать детали различий между экземплярами абстрактного типа. Если взаимодействие между модулями можно выразить в виде полиморфного интерфейса, то имеет смысл их выделить в отдельный модуль ядра. Полиморфизм ценен, когда соответствует понятиям предметной области (фундаментальным). Отделение абстракции позволяет взаимную зависимость модулей дистиллировать связное смысловое ядро

**Рекомендации**
* определить фундаментальные понятия
* выделить через рефакторинг абстрактные классы или интерфейсы
* спроектировать модель так, чтобы выражала большинство взаимодействий между компонентами
* поместить модель в собственный модуль
* конкретные реализации остаются в собственных подобластях
* абстрактное ядро похоже на дистилляционный документ, но в коде

## Дистилляция в углубленных моделях
Дистилляция - не примитивное отделение части предметной области от смыслового ядра. Подобласти совершенствуются, идет движение в сторону углубленной модели и гибкой архитектуры. Углубленная модель сама дистиллирует существенные аспекты предметной области в простые элементы, что вместе дает решать практические задачи, стоящие перед приложением

Качественный скачок в углубленной модели в смысловом ядре может коренным образом изменить характер всего объекта

## Выбор целей рефакторинга
* ищем проблемы в смысловом ядре, взаимосвязях, вспомогательных элементах
* если сами решаем откуда начинать: с реорганизации смыслового ядра, очистки вспомогательных подобластей до состояния неспециализированных

# Крупномасштабная структура
Как сделать архитектуру понятной и вразумительной? Понять, где все модули, как они связаны, куда поместить новый класс. На эти вопросы нужен широкий взгляд

**Рекомендации**
**1. Задача положить структуру на имеющуюся систему.**
Организация уровней, описывающих разные аспекты телекоммуникационной системы
  * нижний уровень физическая инфраструктура (передача данных с узла на узел)
  * маршрутизация пакетов: задачи перенаправления потоков данных 
  * и т.д каждый уровень отражает свою зону ответственности, но все вместе отражают рабочий процесс в системе
  * после проработки (когда система станет многоуровневой) уровни будут переставлять схему правил, взаимоотношений, границ определенного модуля или объекта в целостной архитектуре.
  * это позволяет проще искать ту или иную функции, понимать общую структуру системы
 
**2. разработать схему правил или ролей, отношений, распространяемые на всю систему и позволяющую менять место каждой в едином целом без глубоких знаний** 

**Правило**
Нужно определять модули, чтобы разграничивать уровни

**Уровень** - это совокупность правил более высокого уровня, определяющих границы и взаимоотношения определенного модуля или объекта системы в целостной архитектуре

Разграничение по контекстам предотвращает путаницу, но не облегчает видение системы

В системе, лишенной общего руководящего принципа, который позволяет воспринимать элементы с точки зрения ролей в структурах, разработчики не видят леса за деревьями

**Крупномасштабная структура** - это язык, на котором можно обсуждать, описывать систему крупными мазками

## Эволюционная организация
Если правила мешают разработке, то они возможно слишком жесткие
**3.  Не накладывайте слишком жестких и подробных ограничений на архитектуру и модель. Эти решения принимаются на основе детализированных знаний**
**4. можно накладывать правила на определенные части**
**5. нужно искать компромисс между унификацией структуры и свободой выражения**

* крупномасштабная структура похожа на контуры предметной области и лишена привязки к модели
* предоставляет свободу действий разработчикам в контекстах
* должна вводиться, когда можно найти структуру, которая сделала бы систему понятнее, не должно накладываться неестественных ограничений на развитие модели
* лучше меньше, да лучше. Плохо подходящая структура хуже, чем никакая, лучше искать минимальное решение для возникших проблем

**Структуре нужно следовать всегда, за исключений особых ситуаций(исключений). Если исключений много - обдумать структуру повторно или вообще отбросить**

## Типы крупномасштабных архитектур
### Метафорический образ системы
**Образ системы** - нестрогая ясно понятная крупномасштабная архитектура, находящаяся в соответствии с объектной парадигмой. Образ системы - это аналогия предметной области и приблизительно соответствует рабочей области. Этот образ можно применить в разных ограниченных контекстах, способствуя координированию работ над ними

Чем убедительнее образ, тем больше риск, что архитектура воспримет такие аспекты этой аналогии, которые не желательны при решении конкретной задачи, а какие-то отбросит, и аналогия откажется не успешной

Образ системы полезен лишь для некоторых проектов. Метафора(образ) - должна направить мышление в нужном направлении. Образ нужно включать в единый язык и постоянно испытывать на соответствие задаче. Если будет мешать, надо отказываться. Пример: улей

### Уровень разделения обязанностей
Нужно придать структуру большой модели через структурирование по обязанностям
В некоторых областях имеется расслоение. Понятия существуют в связи с другими, некоторые отдельно, у понятий разная скорость изменения

**Уровни** - это части системы, где элементы могут пользоваться только услугами нижних уровней, но не знают о существовании верхних уровней, а значит, нижние не зависят от верхних

* в моделях, где есть естественное расслоение можно построить уровни вокруг основных групп принципов: многоуровневая архитектура, проектирование по принципу ответственности
* в процессе проектирования модулей и агрегатов выполняется их факторизация, чтобы удержать обязанности в пределах общей схемы

**Многоуровневая структура, подходящая для уровней разделения обязанностей, называется нестрогой многоуровневой системой. В ней компонентам того или иного уровня разрешается обращаться к любым нижним уровням, а не только к тому, который расположен сразу под ними**

**Рекомендации**
* изучить связи модели(концептуальные), скорость изменений в разных частях ПО
* если есть естественное расслоение - представить в виде групп обязанностей
* выполнить рефакторинг, чтобы обязанности каждого объекта предметной области совпадали с обязанностями слоя

**Естественное расслоение - это когда можно говорить о каких-то понятиях обособленно, а какие-то не существуют без других (операции-ресурсы-поддержка решений)**

Каждый из уровней определяется эмпирически, нет решения, нужно заходить самостоятельно. Нельзя сказать сразу куда и какие понятие применить (к какому уровню)

**Если архитектура навязывает неуклюжие решения - ее можно пересмотреть**

**Принципы выделения уровней**
* информативность (должен отражать ключевые приоритеты предметной области). это должно быть не технически-инфраструктурное решение, а модельное
* концептуальная взаимосвязность - понятие верхних уровней должно иметь смысл на фоне поддержки нижних. Нижние должны иметь самостоятельный смысл
* наличие контуров концептуальные: если объекты разных уровней меняются с разной скоростью или по разным причинам, уровни должны отражать наличие сдвигов между ними

**Пример деления**
* потенциал (что можно сделать? с помощью чего?)
* операции (что происходит? что можно извлечь из потенциала?) - связь наверх
* поддержка решений (какие действия предпринять, какой установить регламент)
* регламент (сложные бизнес-требования)
    **Концептуальные взаимосвязи и точки относительного сдвига уровней в системе автоматизации производства**
    | принятие решений| aаналитические механизмы | практически отсутствуют как состояние, так и изменение| анализ управления, оптимизация использования, сокращение рабочего цикла|
    |---------------|--------|------|-----|
    | регламентный| стратегии, связи-ограничения(на основании целей и закономерностей данной отрасли)| медленное изменение состояния| приоритет изделий, предписанные регламенты изготовления деталей|
    |операционный| состояние, отражающее реальное положение дел (деятельности и планов)| быстрое изменение состояния| инвентарная опись, учет состояния незаконченных деталей|
    | потенциальный| состояние, отражающее реальное положение дел (ресурсов)|изменение состояния в среднем темпе| возможности оборудования, наличие оборудования, перемещение по территории|
* обязанности (какие мы дали обещания и кому?) Этот уровень по характеру похож на регламентный в том, что он задает цели для будущих операций, но и на операционный тоже, поскольку обязательства возникают и изменяются в ходе текущей деятельности

### Уровень знаний
**Уровень знаний** - это группа объектов, которая расписывает, как должна вести себя другая группа объектов
Уровень знаний решает задачу того, чтобы часть модели была податливой в руках пользователя и при этом подчинялась широкому набору правил: изменение отношение между сущностями при установке или ходе работы

**Пример** - куча менеджеров над менеджерами, руководящих большими-маленькими группами

Это архитектура, предлагающая пользователю ее конфигурировать для отражения текущего состояния
Если роли и взаимоотношения меняются в разных ситуациях, сложность может нарастать лавинообразно. Ни самые общие, ни самые гибко настраиваемые модели  могут не отвечать потребностям пользователя. Появляются ссылки в объектах на другие типы или атрибуты, которые используются по-разному в разных ситуациях. Множатся классы, содержащие одни и те же данные и операции. 
В модель встраивается другая модель, описывающая ее. Самоопределениие выносится в отдельный уровень знаний, отчего связи-ограничения становятся явными.

**Уровень знаний  - это применение шаблона reflection к предметной области**, но это не говорит, что надо использовать встроенные в язык реализации шаблона reflection

**Рекомендации**
* выделить базовый уровень(base level) - содержатся операционные обязанности
* выделить мета-уровень (meta level) - представляющий знания о строении и поведении программы
* при реализации уровня предметной области не нужно пользоваться рефлексией, реализованной в языке. Эти мета-объекты описывают структуру и функции самих языковых конструкций, а уровень знаний должен строиться из обыкновенных объектов
    * уровень знаний сосредоточен на предметной области и не претендует на максимальную общность (набор ограничений ценнее, чем абстрактная обобщенная архитектурная среда)
* создать набор объектов для описания структуры, функции, связи-ограничения базовой модели
* выделить два уровня: конкретные понятия и правила-знания, изменяемые суперпользователями

**Минусы**
* снижение сложности кода без "всемогущего" объекта
* повышение сложности из-за косвенности связей
* для конфигурирования пользователем нужны знания и навыки
* при изменении архитектуры знаний именно тогда нужно менять операционный уровень

### Среда подключаемых компонентов
Этот подход актуален, когда есть несколько приложений. Когда необходимо взаимодействие между несколькими ограниченными контекстами, как решение, разбивают архитектуру на функциональные компоненты и подключают к центральному распределительному модулю.

Шаблон предлагает использование одного компонента разными приложениями и предлагают организацию распределения обязанностей

**Рекомендация**
* дистиллировать абстрактное ядро интерфейсов и связей
* построить среду или библиотеку , где можно заменять реализации
* предоставить возможность любому из приложений использовать компоненты, но с условием обращения строго через интерфейс абстрактного ядра
* абстрактное ядро содержит общее ядро
* за интерфейсами инкапсулированных компонентов может стоять множество разных контекстов
* структура идеально подходит для разных источников или инкапсулирует ранее написанное с целью интегрирования
* несколько компонентов могут быть в рамках одного контекста

**Минусы**
* сложность
* ограниченная изменчивость приложения
* недостаток вариантов развития (если нужен другой подход в смысловом ядре - этому может помешать крупномасштабная структура), а значит, поменять смысловое ядро

#### Насколько жесткой должна быть структура
* обмен информацией нужно создавать так, чтобы не создавать двусторонних связей между нижними и верхними уровнями
* объекты операционного уровня генерируют события, а регламентный прослушивает (верхний генерирует, нижний слушает). Если событие нарушает регламентное правило, то выполняется ответное действие по правилу, либо генерирует событие более высокого уровня
* жесткая структура рабочего порядка увеличивает единообразие и облегает интерпретацию архитектуры, но бьет по гибкости и специфические схемы коммуникаций , может быть неэффективна между разными контекстами

**Важное достижение крупномасштабной структуры - концептуальная связность и углубление понимания предметной области. Каждое структурное правило должно облегчать разработку**

## Структурирующий рефакторинг
Эволюция значит, что не известна итоговая структура. Это трудно и дорого. 
Методы снижения стоимости при максимизации выгоды
* минимализм: решение насущных и серьезных задач. Выбираем не жесткую структуру, похожую на образ системы, и разделение обязанностей
* коммуникативность и самодисциплина: говорить, обсуждать, чтобы не разлагаться
* реструктуризация дает гибкую архитектуру: переход от образа к уровням. вызвано необходимостью развития, получение новых знаний
* непрерывная дистилляция: например, определение неспецифической подобласти в системе разделения уровней. В подключаемых компонентах может стать общим ядром. Уровни определяются точнее по мере получения знаний

# Определение стратегических подходов
## Сочетание крупномасштабных структур и ограниченных контекстов
**Основные принципы**: компактность, дистилляция, крупномасштабная структура
**Варианты взаимодействия**:
* один контекст, в его пределах крупномасштабная структура (Например уровень разделения обязанностей в рамках одного контекста)
* одна крупномасштабная структура на несколько контекстов. 
* можно организовать карту контекстов в рамках крупномасштабной структуры, а значит, терминология структуры распространится на проекты.
* распределить контексты на уровни, а значит, интеграции считаются расположенными на всех уровнях, а фасады взаимодействия можно вывести на один уровень

Внутри одного контекста может быть своя структура, внутри другого своя, а всю карту организовать в соответствии с третьей

## Сочетание крупномасштабной структуры и дистилляции
* крупномасштабная структура помогает во взаимоотношениях смыслового ядра и неспециализированных подобластей
* помогает дистиллировать смысловое ядро через выделение уровней операций, регламентов
* выделяет подобласти в уровни

## Первоначальная оценка
* начертить карту контекстов. Можно ли, есть ли неоднозначность
* есть ли язык? Богат ли он для помощи в разработке?
* есть ли смысловое ядро? написано ли введение в предметную область? Можно ли написать?
* поможет или помешает проектирование по модели?
* есть ли понимание и интерес к предметной области у разработчиков?

## Кому планировать стратегию
### Самозарождение структуры в ходе разработки
**Требования**
* самодисциплинарная группа, которая может эволюционировать
* человек имеющий большие полномочия. Особенно, если он практикующий разработчик (неформальный лидер)

### Смежная группа по разработке архитектуры
Может существовать группа проектирования архитектуры, которая содержит разработчиков из разных команд

## Шесть принципов принятия решений при стратегическом проектировании
* решения должны доводиться до всех членов группы. Необходим высокий уровень коммуникации. Если его нет, разработчики будет игнорировать решения архитекторов
* в процессе принятия решения необходимо учитывать обратную связь. Архитектор должен слушать идеи исходящие от тех, кто понимает всю глубину процесса - разработчиков
* план должен допускать эволюцию и развитие: не должно быть препятствий для развития проекта. Если план накладывает много ограничений, нужен ли он. О проблемах нужно узнавать от разработчиков
* разработчики архитектуры не должны переманивать лучшие кадры. Если у разработчиков низкие навыки проектирования, то при идеальной архитектуре будет плохая реализация. Также у архитекторов должны быть технически осведомленные разработчики. Необходим баланс.
* в стратегическом проектировании нужен минимализм и скромность. Необходимо сформировать организующие принципы и ключевые модели, очищенные от всего, что не помогает улучшить четкость и ясность архитектуры
* объекты для специализации, разработчики для обобщения. Разработчики не должны быть узкоспециализированными, если им интересна другая область(контекст) - пусть интересуются и взаимодействуют
* необходимо следить за архитектурными средами, если он оказывает влияние на выразительную смысловую реализацию предметной области и внесет изменчивость
* не писать архитектурные среды для "чайников": если считаете, что у людей недостаточно навыков для проектирования, то не надо поручать разработку программ
* долой генеральный план: если он слишком жесток или мягок, тогда в нем нет смысла. На его место ставим ограниченный порядок, приспособленный к реальным обстоятельствам: набор принципов, действующих в отношении всех членов сообщества и применяемый в любой мелкой задаче.
