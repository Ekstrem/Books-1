# Эрик Эванс
# Модель предметной области в работе
## Переработка знаний
Любая система - это цепочка этапов с разветвлениями как условиями или вершинами выбора
### Составление эффективного моделирования
* установка связи межжу моделью и релизацией (Связь с действительностью)
* ввод языка, основанного на модели (Общий понятийный аппарат)
* разработка информоемкая модели (Содержание общией информации разного рода)
* дистиляция модели (Отброс второстепенных понятий либо вон, либо в новую модель)
* мозговые штурмы (Event Storming)

**Переработка знаний**- важный элемент дейтельности программиста. Обработать много информации и сформировать ее в видимую модель. Все это вместе с командой (специалистов предметной области, пользователей систем, технической поддержки).

Плохой стиль переботки - каскадный: специалист -> аналитик -> программист. Знания перетекают в одном направлении и не накапливаются.
Плохой стиль "итерационный": если от специалистов приходят таски по очереди и программисты не пытают абстрагироваться

#### Постоянное обучение
Любая предметная область может приподносить сюрпризы и нельзя ее недооценивать
**NB невежество заставляет делать неверные предположения**
Вся команда должна непрерывно обучаться

#### Информоемкая архитектура
Прояснение через переработку знаний: самых скрытых знаний (правил). Донести важность таких незначительных правил специалистам

#### Углубленные модели
ПОнять что именно необходимо автоматизировать. Первоначальная постановка может быть далека от того, что нужно

## Коммуникация и язык
Модель предметной области может служить основой общего языка для коммуникации в рамках проекта по разработке ПО
**NB Модель - это набор понятий с названиями, терминами, отношениями, взаимосвязями, отражающими понимание предметной области**

**NB Термины и связи - это семантика языка, адаптированная к предметной области**
Язык нужен для разработки информоемкой архитектуры программыю  Отсутствие языка порождает(ухудшает) обмен знаниями не только между специалистами, но и между членами разных команд. Не должно быть перевода между членами.

### Словарь единого языка
* имена классов и основных операций(глаголов)
* термины для обсуждения правил
* термины из принципов высокоуровневой реализации (карта контекстов, крупномасштабная архитектура)
* названия шаблонов

Изменения в языке - это изменения в модели и нужно переименовывать понятия, методы в угоду появившемуся новому знанию
* Нужно старать пользоваться языком, если он неудобен, то это повод пересмотреть термины
* Единый язык должен находить отражение везде: модель (от нее изначально оттталкиваемся), документация, схемы разговор

**Единый язык** - основной носитель тех аспектов, архтектуры, которые не проявляются в коде; крупномасштабной структуре; организающих всю систему, ограниченных контекстов, опредлеляющих отношение между разными системами и моделями, например, шаблонов, относящихся к модели и программной архитектуре

Единый язык сложно внедрять. Может помочь обсуждение вслух: Через дискуссию программисты и специалисты могут найти неточности в ходе своего мышления и, если неточность найдена, ее можно и нужно прояснить.

Единый язык  - это смесь жаргона специалистов, программистов, терминов предметной области. И, как следствие, это потенциальные термины модели, имена ограниченных контекстов и терминология крупномасштабной структуры

### Диаграммы, схемы, диаграммы
* Схемы нужны для более простого взаимодействия (наглядного). Не стоит все переносить на них.
    * Можно нарисовать схему с текстом, определить классы и функции словами
    * Схема может быть от руки, лишь бы была читаема
* Документация характеристики
    * Должна дополнять код и устные обсуждения
    * Код не может быть документацией: слишком сух, а иногда и абстракте(или слишком конкретен)
    * В ней не может быть деталей реализации, это обязанность кода
    * Должна отразить смысл, помочь понять крупномасштабную архитектуру
    * Должна сконцентрировать внимание на ключевых элементах
    * Не должна отставать от процесса
    * Должна меняться и должна быть гибкой(без лишних инструкций и уточнений)

Документация должна:
* разъяснить понятийный аппарат модели
* помогать ориентироваться в деталях кода
* дать понимание, как должна использоваться модель
* должна быть написана на едином языке
* должна помочь в написании ТЗ, пользовательской документации

**Если документация не влияет на единый язык, т.е ее не заполняют, не используют, то она либо составлена неверно (слишком много - слишком мало), либо не отражает реальной стадии разработки**

### Пояснительная модель
Модель, по которой выполняется проектирование - это один взгляд на проблему, но для обучения, ввода в курс дела полезно иметь вспомогательные точки зрения для лучшей передачи общих данных
Можно предствить предметную область, как пояснительную модель. Пояснительную модель можно расширять схемой или документацией. Например, есть модель в системе терминов, но для непосвященных это может лишь запутать ситуацию и тут-то является пояснительная модель (схема, график) для более наглядного представления. А модель  - это список связей с блоками, отражающая архитектуру приложения, в виде более строгихдиаграмм, таблиц, схем. 
**Важно четко понимать разницу между пояснительной моделью и рабочую модель**

# Связь между моделью и реализацией
Иногда сформуированная модель может быть очень детальной и подробной, но при попытке ее реализовать оказывается множество связей и связности. Т.е она не влияет на разработку разработку
**Модель в DDD  - прочный фундамент для архитектуры приложения**

## Проектирование по модели
Аналитическая модель - результат ананлиза прикладной темы, ее систематизация без учета роли, которую она будет играть в программной системе. Программная архитектура строится опосредовано по аналитической модели, лишь ссылаясь как на "логику" поведения. Но фактически модель не всегда помогает понять предметную область, напротив, запутывая ее.
**Иногда из-за наличия аналитиков разработчики не имеют возможности принять участие в анализе**

## Этапы проектирования и анализа
* Извлечь фундаментальные понятия и представить их (анализ)
* Задать набор компонентов, которые конструируются с помощью средств разработкидля решения поставленной задачи (проектирование)
* поиск модели между анализом и архитектурой (MDD - model driver design)
Как следствие получаем единый процесс моделирования и проектирвоания.

Модель должна использовать единый язык. Модель будет совершенствоваться итерационно. Вокруг нее будет строиться проектирование

## Парадигмы моделирования и средства программирования
* Процедурная
* Логическая
* ООП

Каждая из них выполняет свою задачу. И исходя из ориектирования вокруг модели можно выбрать, например, ООП или функциональную парадигму. Архитектура тянет парадигму.

## Анатомия модели
Проектирование модели требует работы только с одной моделью. Никаних дополнительных, избыточных или усеченных модулей. Все строится вокруг полной модели

## Моделировщики практики
Высококвалифицированные конструируют и моделируюит, остальные реализуют. 
НО DDD требует проектирования от всех. 
* Если одни проектируют, а другие пишут код, то теряется владение знанием, получается испорченный телефон. Программисты не чувствуют ответственности за модели и не понимают ее необходимости. Не будут понимать, что изменение кода ведет к изменению модели, тогда их рефакторинг будет вредить.
* Проектировщик будет терять связь с миром технологий, пониание требований и собенности реализации. В обсуждении рождается истина. Даже если выделены проектироващики, они должны тесно взаимодействавать и обсуждать концепции с разработчиками

# Изоляция предметной области
## Многоуровневая архитектура
Необходимо ограничить объекты предметной области от общих функций системы и избежать путаницы между понятиями предметной области и остальных функций системы.

Уровни: 
* **Интерфейс пользователя**вывод информации пользователю, интерпретирование его команд. Внешним субъектом может быть не только человек, но и информационная система. 
* **Операционный** - распрделение работы между совокупностями на более низкие уровни. В нем нет отражения состояния, объектов, предметов прикладной модели, но может быть состояние, для информирования ользователя о степени выполнения задачи
* **Предметной области** прелставляет понятие прикладной предметной области, рабочие состояния, деловые регламенты. Здесь используется текущее состояние прикладной модели, этот уровень главная алгоритмическая часть
* **Инфраструктурный** - техническая поддержка верхних уровней, берет на себя поддержку схему взаимосвязей между всеми уровнями. 
**Когда код размазал по базе фронту его сложнее анализировать, изменять и искать. Получается каждое изменение влечет непредсказуемое поведение в лругих слоях.**

Основной принцип многоуровневой архитектуры - каждый уровень зависит от работы элеиентов этого кровня и от более низких уровней. **Ценность многоуровневости** - это специализация каждого уровня на конкретном аспекте программы. Уровней может быть больше, но все они должны следовать главному правилу.

Разные уровни можно разместить на разных серверах.
**Необходимость операционного уровня: при измении испочника запроса - точка всегда юудет единой, помогает поддерживать архитектуру в целостном виде**

### Связь между уровнями
* Уровни должны быть связаны нежестко и сверху-вниз
* верхние уровни манипулируют нижними через вызов публичных методов, хранения ссылок на них
* если нужна связь снизу вверх, то нужно реализовывать сообщениями или паттерном наблюдатель
* инфраструктурный уровень не инициирует операций на уровне предметной области
* техничесике возможности(инфраструктурный уровень) предоставляются в виде служб, например, посласть письмо: оперативный уровень запрашивает передачу сообщения - это дополнительная помощь для операционного уровня, но при этом он не знает технической сложности службы
* некоторые технические компоненты проектируются так, чтобы напрямую поддерживать функционирование других уровней(абстрактный базовый класс)

### Архитектурные среды
Речь идет об инфраструктурном уровне, где не все решается использованием интерфейсов. Среды, которые могут влиять на предметный уровень. Например решение реализовать модель в виде объектов конкретной ORM. Важно не выбирать жестко готовое решение раз и навсегда, а делать выбор в пользу полезности для работы над предметной моделью

## Уровень предметной области- вместилище модели
**Для DDD ключевой областью(слоем) является предметной слой, уровень предметной области**
Модель предметной области(**domain model**) - это набор понятий. Уровень предметной области (layer) - выражение данной модели и всех элементов программной архитектуры, имеющие к ней отношение. Этот уровень образуется путем проектирования и реализации всей совокупности понятий и связей в предметной области. Такого рода проектирование, конструкции уровня предметной области отражают концепции модели.
**Изрляция предметной области - это основа DDD**

## Антипаттерн интеллектуального интерфейса пользователя
Реализация логики внутри интерфейса пользователя. Хранение - общая реляционная БД. Плюсы и минусы очевидны.

# Модель, выраженная в программе
Связь между моделью и реализацией необходимо проектировать на уровне деталей.

**Основное различие сущности  и объекта-значения в том, что сущность имеет протяженность и обособленность, а объект-значение  выражает состояние предметной области.**

Служба(Services)  - это что-то срабатывающее на запрос клиента. На уровне предметной области они появляются при моделировании деятельности, которая соответствует опрерациям программы, но не ассоциируется ни с каким ее состоянием.

## Ассоциации
При необходимости соблюсти однозначное соответствие между моделью и программной реализацией сложнее всего при создании ассоциаций между объектами
Для всякой прослеживаемой в модели ассоциации должен существовать механизм в программе, обладающий теми же свойствами (связь между покупателем и продавцом в магазине, связь в коде между объектами). **Реализация может быть разной, но должна быть в архитекутре предусмотрена**

### Правила упрощения ассациаций
1. Свести отношения к однонаправленным (снижает связность и упрощает структуризацию)
    * Отпределить, какое соотношение важнее (отель в какой стране? - какие отели в стране?)
    * Можно последовательно пытаться ограничить ассоциации и , как следствие, упростить и сделать значимыми оставшиеся ассоциации
2. Добавить квалификаторы
    * путин - президент? президент какой страны путин? - класс человек независим от менее функдаментального президент.
        Выбор главного направления из "многие ко многим" сужает его к "один к одному"
3. устранить несущественные ассоциации

## Сущности
Многие объекты не сводятся к набору атрибутов, а характеризуются непрерывностью и индивидуальностью существования. Индентичность - это то, что определяет именно его. (Как определить, что сущность(человек) именно тот, кем является?)
Десять лет назад для понимания сущности главное не атрибуты, а абстрактное непрерывное существование в течение всего жизненного цикла, даже с переходом в разные формы

Для некоторых объектов опредление через атрибуты не главное. Они непрерывно существуют во времени, переходят в состояния, но не утрачивают своего значения (понимания-смысла). Может существовать две сущности с одинаковыми атрибутами, но разными по факту.
* Эти обекты должны идентифицироваться таким образом, чтобы их можно было однозначно опредить.
* Определение классов обязанностей, атрибутов, ассоциаций для них следует строить вокруг смыслового значения, а не атрибутов (человек, город, авто, билет и т.д)

**Индивидуальное существование  - это тонкий смысловой атрибут, который невсегда возможно превратить в стандартное средство единого языка**

**Иногда имеет смысл посмотреть на транзакцию, как на сущность**

### Правила
* если объект определяется индивидуальным существованием, а не набором атрибутов, это свойство следует следует считать главным в определении объекта в модели
* класс должен строиться вокруг непрерывности и уникальности цикла объекта
* найти способ разлисать объект вне зависимости от формы и существования
* обратить внимание к техническими требованиям, необходимым для сопоставления объектов по атрибутам
* создать операцию, которая способна генерировать новый результат для объекта(например, GUID). Она(операция) должна соответствовать правилам различения объектов в модели.
* должно даваться точно определение, что такое разные объекты
* если у объекта нет уникального признака (место без номера), то, возможно, это не сущность

## Моделировани сущностей
При моделировании объекта нужно думать об атрибутах и важно думать о его поведении, рабочих функциях.
Основная функция сущности - поддерживать непрерывность существования, чтобы поведение было понятным и предсказуемым. как следствие выведем правила:
1. ограничиваем определение сущности неотъемлемыми характеристиками (то что используется для поиска и сравнения)
2. задаем только те функции, которые существенны для создания понятия об объекте 
3. задать атрибуты, которые требуют функции (2)
4. остальные атрибуты и функции и объекты выносим в другие функции или объекты-знаечния

**Функции координируют операции объектов, которые им принадлежат. Номер телефона не может быть уникальным, но можно вынести в деловые контакты**

## Проектирование операций идектификации
* может быть некоторый уникальный признак
* если нет - присваиваем уникальный код сами (в рамка плана уникальный)
* могут быть разные способы генерации (важно помнить о том, что система может быть рапределеннной)
* идентификатор может быть внутренним (не нужно показыать пользователям). Могут быть необходимы для пользователя (коды подтверждения для токенов в письмах)
* если нужен общий для разных организаци (например использование федерального или общепринятого справочника)
* иногда можно ожидать определения индивидуальных идентификаторов от пользователя (логин - почта)

##  ОБъекты-значения
ОБъекты без индивидуального существования описывают характристики того или иного объекта

**Пример** Рисунок - сущность, чем его рисовали и вкакой технике - характеристики

**Один и тот же объект в разных ситуациях может быть сущностью или объектом-значением.** Адреса для человека - это объект-значение, а для ФИАС  - сущность

Объект-значение  - это объек, представляющий описанный аспект предметной области и не имеет индивильного существования, собственной идентичности
* объект-значение может представлять совокупность других объектов
* может ссылаться на сущности (нужный маршрут состоит из сущностей населенный пункт, дорога)
* может персылаться в сообщениях между объектами
* может носит временный характер
* может использоваться как атрибут сущности (человек - сущность, объект-знаечние - имя)
**если элемент модели определяется своими атрибутами(полностью), то это объект-значение**
* сделайте, чтобы объект-знаечние отражал смысл заложенных в него атрибутов атрибутов, придайте соответствующую функциональность
* нужно считать его неизменяемым
* не должен содержать индивидуальности
* должен быть целостным (не три значения улица, город, страна), а одно - адрес

### Проектирование объектов-знаечний
Есть одно имя у двух человек. Один имя поменял. Менять ззначение объекта нельзя, так как изменится имя другого человека 
Можно сделать вывод:
* объект-знаечния не изменяем, а заменяем
* может быть многократно используем для разных сущностей (с сущностью такое не пройдет)

#### Случаи изменяемости
* частое изменение
* затраты создание-уничтожения
* опасность замены при группировании (совместное использование)
  если объект-знаечниие изменяем, то он не должен использоваться совместно

**Чтобы иметь возможность технически оптимизировать быстродействие, необходимо избегать связей и ограничений в модели**

**!! В реляционной БД можно провести донормализацию с целью засунуть объект-знаечние из отдельной таблицы в таблицу-сущности. Для экономии времени**

**В распределенной  системе, если хранить ссылку на объект-значение на другом сервере, может замедлиться передача сообщений, поэтому лучше передавать на другой сервер копию объета**

Нужно избегать двунаправленной ассациации между объектами-значениями

## Службы
* служба не инкапсулирует состояние 
* большинство служб находятся на инфраструктурном уровне и имеют технический характер
* службы на уровне предметной области взаимодействуют с инфраструктурными (при изменении баланса  - отсылаем письмо)
* отличить службы операционного уровня и предметной области: операционный уровень отдаем команду на перевод денег, а реализация перевода денег - фундаментальная операция предметной области **Грань тонка**
* в службах предметной области реализуются деловые регламенты

### Распределение служб по уровням
#### Операционный
* принимает входные данные
* посылает сообщение в службу модели для выполнения
* ожидает подтверждения
* принимает решение об отправке извещения

#### Предметной области
* взаимодействует с нужными объектами
* посылает подтверждение результата

#### Инфраструктурный
* рассылка
* экспорт

## Модули
### Цели
* уменьшить смысловую сложность
* удобно прослеживать архитектурные решения через связи модулей

### Характеристики
* низкая внешняя зависимость и сильная внутренняя связанность
* помогают строить все так, чтобы не нарушать границ модуля
* позволяют развивать модуль внутри модуля
* должны входить в единый язык
* должны рассказывать историю системы

### Ловушки инфраструктуры
* нельзя разделить концептуальный объект на части (Razor, WinForm)
* обязательный пакеты накладывают ограничения

### Парадигмы моделирования
**Объектная** - простота,  популярность, комьюнити  необъекты в объектном мире (логическая). Зависим от математических соглашений
**Логическая** - необъекты в объектном мире.
**Функциональная**

#### Смешение парадигм. Советы
* не противостоять парадигме реализации (искать то, что будет соответствовать)
* полагаться на единый язык
* не зацикливаться на UML
* подвергать все сомнению
* исчерпать все в рамках текущей пардигме

# Цикл существования объектов модели
Каждый объект имеет цикл существования (создание - модификация - архив - удаление).
Существуют временные и долгоиграющие объекты (со сложными связями, изменением состояния, подчиняется инвариантоности)

## Трудности управления объектами
* поддрежание целостности на этапе существования
* предотвращение излишней сложности в управлении циклом существования

**Шаблоны для разрешения трудностей**
* Агрегаты - помогают в поддержании целостности объектов
* Фабрики - создание - восстановление сложных объектов
* Хранилища - поиск и извлечение

## Агрегаты
**Проблема**
При внесении изменений в объекты модели со сложной системой ассоциаций можно получить несогласованные данные. Необходимо соблюдать инварианты к тесно связанным группам объектов, а не к отдельным объектам. Если переборщить со схемами блокирования, то будут проблемы с параллельной работой.

**Помогают решению**
* знание предметной области
* знание частоты смены экземпляров объектов
* построение модели с большой свободой в местах интенсивной передачи конкурирующих данных
* построить моделт, принуждающую к соблюдению инварианта

**Корень проблемы**
* нечеткие границы

**Правила для танзакций, вносящих изменения и в первичные, и в связыные объекты**
* абстракция для инкапсулрующих ссылок в пределах модели (Агрегат)

**Агрегат состоит:**
**Корень агрегата** (корневой объект) - это конкретный объект-сущность
 * сущности снаружи агрегата ссылаются на него
 * объекты внутри границы могут ссылаться друг на друга
 * сущности внутри корневого объекта могут быть локально индивидуальны, но только в пределах границ. Снаружи доступа нет.
      Пример: Шины у машины. Внешний номер машины - известен за пределами границ. Уникальность конкреной шинынеобходима только в рамках конкретной машины.

**Из взаимосвязей между объектами агрегата можно составить инварианты - Правила совместности, которые должны соблюдаться при любых изменениях данных. это правило должно контролировать при завершении любой транзакции**

### Правила создания агрегата
* корневой объект имеет глобальную идентичность и несет ответственность за проверку инвариантов
* некорневые объекты-сущности имеют локальную идентичность
* ничто, кроме корня агрегаты не открываются за пределы границ для сохранения
* корневой объект может передавать ссылки на внутренние объекты-сущности другим объектам, НО во временное пользование без хранения или фиксирования (на время существования операции)
* корневой объект может передавать копию объекта-значения. Его дальнейшая судьба не важна.
* только корневой агрегат можно получать по запросами к источнику данных. все остальное разрешается извлекать по цепочке связей
* объекты внутри агрегаты могут хранить ссылки на корневые объекты других агрегатов
* удаление удаляет все в границах агрегата
* при изменении любого объекта внутри границ агрегата удовлетворятся все инварианты агрегата
**Пример инварианта - сумма не больше предела**

## Фабрики
Фабрики обеспечивают инкапсуляуцию внутри агрегата: Когда создание объекта перекладывается на клиента это:
* не соответствует принципу SRP
* утечка обязанности из предметной области
* брешь инкапсуляции

**Объект необходимо дистилировать, пока в нем не останется ничего, что имеет отношение к его сути и его роли в транзакциях**

Создание сложных объектов - это обязанность предметной области, но не объектов, выражающих модель
**Обязанность фабрики - создавать объекты**
* интерфес объекта должен инкапсулировать реализацию
* фабрика инкапсулирует знания для создания сложного объекта или агрегата

**Шаги создания сложного объекта и агрегата**
* передать обязанности создания объекта фабрике (задача по созданию передана отдельному классу)
* создать интерфейс инкапсулирующий сложные операции и не требует от лиента ссылаться на конкретные классы
* создайте агрегат как единое целое с соблюдением инварианта

**Требования к фабрикам**
* один метод создания - должен гарантировать соблюдение инваринта
* создавать объект целиком в корректном состоянии (для сущности создается целый агрегат с соблюдением всех инварианта, можно позже добавить второстепенные элементы; для собъекта-значения - это значит, что все атрибуты иниуиализируются всеми окончательными корректными значениями)
* если есть возможность ввода некорректного значения долна инициироваться исключительная ситуация
* абстрагировать фабрику нужно к желаемому типу, а не к конкретному классу

### Выбор фабрик и их местонахождения
* если добавляются элементы внутрь уже существующего агрегата - в корневом объекте агрегата создать фабрику
* если объект участвует в порождении дургого объекта, но не владеет им после создания - в него можно поместить метод-фабрику для создания не основого объекта
* фабрику помещаем только в объект, где сильная естественная связь с порождаемым объектом
* если нужно скрыть реализацию или сложность процесса создания, но нет естественного объекта лдля инкапсуляции - нужна специальная фабрика или служба. Такая автономная фабрика порождает агрегат, вызывая ссылку на корневой объект (и инваринат соблюдает)
* если нужна фабрика для внутреннего объекта по отношению к агрегату (например корень не подходит) - фабрика, НО! на порождаемый объект возможны только врменные ссылки извне агрегата.

**Когда достаточно конструктора**
* класс является типом, не входит в иерархию, не используется полиморфиески
* клиенту нужно знать реализацию объекта (например для выбора стратегии)
* все атрибуты объекта доступны клиенту (в конструкторе не создаются никакие новые объекты)\
* простое создание объекта
* общедоступный конструктор должен следовать тем же правила, что и фабрика
**Конструктор в конструкторе  - это плохо. Конструкторы должны быть простыми**

### Проектирование интерфейса
* каждая операция единая и неделимая (все данные для создания передаются в одну коммуникацию) Важно решить, что делать с исключениями (нужен единый стандарт)
* фабрика должна быть связана со своими аргументами . Если неосотрожно выбрать набор входных параметров, то может получиться паутина взаимосвязей(если сразу вставляются значения - низкая зависимость, если при конструировании берется только часть от объекта, то зависимость становится сильнее)
* используйте абстрактный тип аргумента, а не конкретные классы. (фабрика привязана к конкретному типу продуцируемых объектов, нет нужды привязывать в конкретным параметрам)

**Самые безопасные параметры - с нижних уровней архитектуры или близкородственный к генерируемому так что между ними не создается новая взаимозависимость (товарный заказ - позиция товарного заказа - товар)**

### Где релизовывать логику инваринтов
* Проверка выполнения инвариантов - фабрика. Идеальный случай: фабрика делегирует проверку объекту. 
* Иногда можно вынести в саму фабрику, не загромождая создаваемые объекты, например, для правил распространяемых на много объектов
* можно вынести в саму фабрику если логика не будет меняться в течение существования. например все характеристики у объекта-сущности - неизменяемые объекты-знаечния, тогда незачем тащить логику проверки инварианта в объект.

### Отличие фабрик-сущностей от фабрик-объектов-значений
* ОБъекты-значений создают в окончательном виде и фабрика должна задавать полное описание продукта
* Фабрики-сущности склонные работать с самыми существенными атрибутами для создания корректного агрегата и соблюдения инварианта, а детали позже. Плюсы: контроль над процессом создания индентификатора.
* если необходим извне получать уникальный идентификатор, то его контроль удобно возложить на фабрику. Даже в случае автогенерации ключа(база, внешний механизм) - фабрика знает, куда его поместить и откуда запросить

### Восстановление храниных объектов
Восставновление объекта в памяти - это сбор отдельных частей заново в единое целое. (Середина жизни цикла объекта)
* Восстанавливает объект-сущность, не присваивая идентификационный номер (иначе это было бы не предыдущее состояние, а новый объект, поэтому идентификатор должен сохраняться во входных параметрах фабрики)
* Восстанавливающая объект по-другому обрабатывает нарушение инварианта
    * при создании фабрика обычно просто сбрасывает объект
    * для восстановления должна быть схема разрешения противоречий






















































